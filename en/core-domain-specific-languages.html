<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.0.preview.7">
<title>Domain-Specific Languages</title>
<link rel="stylesheet" href="assets/css/style.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/font-awesome/3.2.1/css/font-awesome.min.css">
<link rel="stylesheet" href="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.css">
<script src="http://cdnjs.cloudflare.com/ajax/libs/prettify/r298/prettify.min.js"></script>
<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>
<link rel="stylesheet" href="assets/css/view-example.css">
<script src='assets/js/jquery-2.1.1.min.js'></script>
<script src='assets/js/view-example.js'></script></head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Domain-Specific Languages</h1>
<span id="revnumber">version 2.3.6</span>
<div id="toc" class="toc2">
<div id="toctitle">Table of Contents</div>
<ul class="sectlevel1">
<li><a href="core-domain-specific-languages.html#_command_chains">1. Command chains</a></li>
<li><a href="core-domain-specific-languages.html#_operator_overloading_tbd">2. Operator overloading (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_script_base_classes_tbd">3. Script base classes (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_adding_properties_to_numbers_tbd">4. Adding properties to numbers (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#section-delegatesto">5. @DelegatesTo</a></li>
<li>
<ul class="sectlevel2">
<li><a href="core-domain-specific-languages.html#TheDelegatesToannotation-DSLsmadeeasy">5.1. Explaining delegation strategy at compile time</a></li>
<li><a href="core-domain-specific-languages.html#TheDelegatesToannotation-DelegatesTo">5.2. @DelegatesTo</a></li>
<li><a href="core-domain-specific-languages.html#TheDelegatesToannotation-DelegatesTomodes">5.3. DelegatesTo modes</a></li>
<li>
<ul class="sectlevel3">
<li><a href="core-domain-specific-languages.html#TheDelegatesToannotation-Simpledelegation">5.3.1. Simple delegation</a></li>
<li><a href="core-domain-specific-languages.html#TheDelegatesToannotation-Delegationstrategy">5.3.2. Delegation strategy</a></li>
<li><a href="core-domain-specific-languages.html#TheDelegatesToannotation-Delegatetoparameter">5.3.3. Delegate to parameter</a></li>
<li><a href="core-domain-specific-languages.html#TheDelegatesToannotation-Multipleclosures">5.3.4. Multiple closures</a></li>
<li><a href="core-domain-specific-languages.html#_delegating_to_a_generic_type">5.3.5. Delegating to a generic type</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="core-domain-specific-languages.html#compilation-customizers">6. Compilation customizers</a></li>
<li>
<ul class="sectlevel2">
<li><a href="core-domain-specific-languages.html#_introduction">6.1. Introduction</a></li>
<li><a href="core-domain-specific-languages.html#_import_customizer">6.2. Import customizer</a></li>
<li><a href="core-domain-specific-languages.html#_ast_transformation_customizer">6.3. AST transformation customizer</a></li>
<li><a href="core-domain-specific-languages.html#_secure_ast_customizer">6.4. Secure AST customizer</a></li>
<li><a href="core-domain-specific-languages.html#_source_aware_customizer">6.5. Source aware customizer</a></li>
<li><a href="core-domain-specific-languages.html#_customizer_builder">6.6. Customizer builder</a></li>
<li>
<ul class="sectlevel3">
<li><a href="core-domain-specific-languages.html#_import_customizer_2">6.6.1. Import customizer</a></li>
<li><a href="core-domain-specific-languages.html#_ast_transformation_customizer_2">6.6.2. AST transformation customizer</a></li>
<li><a href="core-domain-specific-languages.html#_secure_ast_customizer_2">6.6.3. Secure AST customizer</a></li>
<li><a href="core-domain-specific-languages.html#_source_aware_customizer_2">6.6.4. Source aware customizer</a></li>
<li><a href="core-domain-specific-languages.html#_inlining_a_customizer">6.6.5. Inlining a customizer</a></li>
<li><a href="core-domain-specific-languages.html#_multiple_customizers">6.6.6. Multiple customizers</a></li>
</ul>
</li>
<li><a href="core-domain-specific-languages.html#_config_script_flag">6.7. Config script flag</a></li>
<li>
<ul class="sectlevel3">
<li><a href="core-domain-specific-languages.html#_static_compilation_by_default">6.7.1. Static compilation by default</a></li>
</ul>
</li>
<li><a href="core-domain-specific-languages.html#_ast_transformations_tbd">6.8. AST transformations (TBD)</a></li>
</ul>
</li>
<li><a href="core-domain-specific-languages.html#_custom_type_checking_extensions_tbd">7. Custom type checking extensions (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_builders_tbd">8. Builders (TBD)</a></li>
<li>
<ul class="sectlevel2">
<li><a href="core-domain-specific-languages.html#_creating_a_builder_tbd">8.1. Creating a builder (TBD)</a></li>
<li>
<ul class="sectlevel3">
<li><a href="core-domain-specific-languages.html#_buildersupport_tbd">8.1.1. BuilderSupport (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_factorybuildersupport_tbd">8.1.2. FactoryBuilderSupport (TBD)</a></li>
</ul>
</li>
<li><a href="core-domain-specific-languages.html#_existing_builders_tbd">8.2. Existing builders (TBD)</a></li>
<li>
<ul class="sectlevel3">
<li><a href="core-domain-specific-languages.html#_markupbuilder_tbd">8.2.1. MarkupBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_streamingmarkupbuilder_tbd">8.2.2. StreamingMarkupBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_saxbuilder_tbd">8.2.3. SaxBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_staxbuilder_tbd">8.2.4. StaxBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_dombuilder_tbd">8.2.5. DomBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_nodebuilder_tbd">8.2.6. NodeBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_jsonbuilder_tbd">8.2.7. JsonBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_streamingjsonbuilder_tbd">8.2.8. StreamingJsonBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_swingbuilder_tbd">8.2.9. SwingBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_antbuilder_tbd">8.2.10. AntBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_clibuilder_tbd">8.2.11. CliBuilder (TBD)</a></li>
<li><a href="core-domain-specific-languages.html#_objectgraphbuilder_tbd">8.2.12. ObjectGraphBuilder (TBD)</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_command_chains">1. Command chains</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Groovy lets you omit parentheses around the arguments of a
method call for top-level statements. &#8220;command chain&#8221; feature extends this by allowing us to chain such
parentheses-free method calls, requiring neither parentheses around arguments, nor dots between the chained calls.
The general idea is that a call like <code>a b c d</code> will actually be equivalent to <code>a(b).c(d)</code>. This
also works with multiple arguments, closure arguments, and even named arguments. Furthermore, such command chains can
also appear on the right-hand side of assignments. Letâ€™s have a look at some examples
supported by this new syntax:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">// equivalent to: turn(left).then(right)
turn left then right

// equivalent to: take(2.pills).of(chloroquinine).after(6.hours)
take 2.pills of chloroquinine after 6.hours

// equivalent to: paint(wall).with(red, green).and(yellow)
paint wall with red, green and yellow

// with named parameters too
// equivalent to: check(that: margarita).tastes(good)
check that: margarita tastes good

// with closures as parameters
// equivalent to: given({}).when({}).then({})
given { } when { } then { }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is also possible to use methods in the chain which take no arguments,
but in that case, the parentheses are needed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">// equivalent to: select(all).unique().from(names)
select all unique() from names</code></pre>
</div>
</div>
<div class="paragraph">
<p>If your command chain contains an odd number of elements, the chain will
be composed of method / arguments, and will finish by a final property
access:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">// equivalent to: take(3).cookies
// and also this: take(3).getCookies()
take 3 cookies</code></pre>
</div>
</div>
<div class="paragraph">
<p>This command chain approach opens up interesting possibilities in terms of the much wider range of DSLs which
can now be written in Groovy.</p>
</div>
<div class="paragraph">
<p>The above examples illustrate using a command chain based DSL but not how to create one. There are various strategies
that you can use, but to illustrate creating such a DSL, we will show a couple of examples - first using maps and Closures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">show = { println it }
square_root = { Math.sqrt(it) }

def please(action) {
  [the: { what -&gt;
    [of: { n -&gt; action(what(n)) }]
  }]
}

// equivalent to: please(show).the(square_root).of(100)
please show the square_root of 100
// ==&gt; 10.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a second example, consider how you might write a DSL for simplifying
one of your existing APIs. Maybe you need to put this code in front of
customers, business analysts or testers who might be not hard-core Java
developers. Weâ€™ll use the <code>Splitter</code> from the Google
<a href="http://code.google.com/p/guava-libraries/">Guava libraries</a> project as it
already has a nice Fluent API. Here is how we might use it out of the
box:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()</code></pre>
</div>
</div>
<div class="paragraph">
<p>It reads fairly well for a Java developer but if that is not your target
audience or you have many such statements to write, it could be
considered a little verbose. Again, there are many options for writing a
DSL. Weâ€™ll keep it simple with Maps and Closures. Weâ€™ll first write a
helper method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@Grab('com.google.guava:guava:r09')
import com.google.common.base.*
def split(string) {
  [on: { sep -&gt;
    [trimming: { trimChar -&gt;
      Splitter.on(sep).trimResults(CharMatcher.is(trimChar as char)).split(string).iterator().toList()
    }]
  }]
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>now instead of this line from our original example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def result = Splitter.on(',').trimResults(CharMatcher.is('_' as char)).split("_a ,_b_ ,c__").iterator().toList()</code></pre>
</div>
</div>
<div class="paragraph">
<p>we can write this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def result = split "_a ,_b_ ,c__" on ',' trimming '_\'</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_operator_overloading_tbd">2. Operator overloading (TBD)</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_script_base_classes_tbd">3. Script base classes (TBD)</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_adding_properties_to_numbers_tbd">4. Adding properties to numbers (TBD)</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="section-delegatesto">5. @DelegatesTo</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="TheDelegatesToannotation-DSLsmadeeasy">5.1. Explaining delegation strategy at compile time</h3>
<div class="paragraph">
<p><code>@groovy.lang.DelegatesTo</code> is a documentation and compile-time annotation aimed at:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>documenting APIs that use closures as arguments</p>
</li>
<li>
<p>providing type information for the static type checker and compiler</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Groovy language is a platform of choice for building DSLs. Using
closures, itâ€™s quite easy to create custom control structures, as well
as it is simple to create builders. Imagine that you have the following
code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">email {
    from 'dsl-guru@mycompany.com'
    to 'john.doe@waitaminute.com'
    subject 'The pope has resigned!'
    body {
        p 'Really, the pope has resigned!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>One way of implementing this is using the builder strategy, which
implies a method, named <code>email</code>Â which accepts a closure as an argument.
The method may delegate subsequent calls to an object that implements
theÂ <code>from</code>,Â <code>to</code>,Â <code>subject</code> andÂ <code>body</code> methods. Again,Â <code>body</code> is a
method which accepts a closure as an argument and that uses the builder
strategy.</p>
</div>
<div class="paragraph">
<p>Implementing such a builder is usually done the following way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def email(Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>the <code>EmailSpec</code> class implements theÂ <code>from</code>,Â <code>to</code>, â€¦ methods. By
callingÂ <code>rehydrate</code>, weâ€™re creating a copy of the closure for which we
set theÂ <code>delegate</code>,Â <code>owner</code> andÂ <code>thisObject</code> values. Setting the owner
and the <code>this</code> object is not very important here since we will use the
<code>DELEGATE_ONLY</code> strategy which says that the method calls will be
resolved only against the delegate of the closure.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class EmailSpec {
    void from(String from) { println "From: $from"}
    void to(String... to) { println "To: $to"}
    void subject(String subject) { println "Subject: $subject"}
    void body(Closure body) {
        def bodySpec = new BodySpec()
        def code = body.rehydrate(bodySpec, this, this)
        code.resolveStrategy = Closure.DELEGATE_ONLY
        code()
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>EmailSpec</code> class has itself a <code>body</code> method accepting a closure that is cloned and executed. This is what
we call the builder pattern in Groovy.</p>
</div>
<div class="paragraph">
<p>One of the problems with the code that weâ€™ve shown is that the user of
the <code>email</code> method doesnâ€™t have any information about the methods that
heâ€™s allowed to call inside the closure. The only possible information
is from the method documentation. There are two issues with this: first
of all, documentation is not always written, and if it is, itâ€™s not
always available (javadoc not downloaded, for example). Second, it
doesnâ€™t help IDEs. What would be really interesting, here, is for IDEs
to help the developer by suggesting, once they are in the closure body,
methods that exist on the <code>email</code> class.</p>
</div>
<div class="paragraph">
<p>Moreover, if the user calls a method in the closure which is not defined
by theÂ <code>EmailSpec</code> class, the IDE should at least issue a warning (because
itâ€™s very likely that it will break at runtime).</p>
</div>
<div class="paragraph">
<p>One more problem with the code above is that it is not compatible with static type checking. Type checking would let
the user know if a method call is authorized at compile time instead of runtime, but if you try to perform type
checking on this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">email {
    from 'dsl-guru@mycompany.com'
    to 'john.doe@waitaminute.com'
    subject 'The pope has resigned!'
    body {
        p 'Really, the pope has resigned!'
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then the type checker will know that thereâ€™s anÂ <code>email</code> method accepting
aÂ <code>Closure</code>, but it will complain for every method callÂ <strong>inside</strong> the
closure, becauseÂ <code>from</code>, for example, is not a method which is defined
in the class. Indeed, itâ€™s defined in theÂ <code>EmailSpec</code> class and it has
absolutely no hint to help it knowing that the closure delegate will, at
runtime, be of typeÂ <code>EmailSpec</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TypeChecked
void sendEmail() {
    email {
        from 'dsl-guru@mycompany.com'
        to 'john.doe@waitaminute.com'
        subject 'The pope has resigned!'
        body {
            p 'Really, the pope has resigned!'
        }
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>will fail compilation with errors like this one:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>[Static type checking] - Cannot find matching method MyScript#from(java.lang.String). Please check if the declared type is right and if the method exists.
 @ line 31, column 21.
                       from 'dsl-guru@mycompany.com'</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="TheDelegatesToannotation-DelegatesTo">5.2. @DelegatesTo</h3>
<div class="paragraph">
<p>For those reasons, Groovy 2.1 introduced a new annotation
namedÂ <code>@DelegatesTo</code>. The goal of this annotation is to solve both the
documentation issue, that will let your IDE know about the expected
methods in the closure body, and it will also solve the type checking
issue, by giving hints to the compiler about what are the potential
receivers of method calls in the closure body.</p>
</div>
<div class="paragraph">
<p>The idea is to annotate theÂ <code>Closure</code> parameter of theÂ <code>email</code> method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def email(@DelegatesTo(EmailSpec) Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>What weâ€™ve done here is telling the compiler (or the IDE) that when the
method will be called with a closure, the delegate of this closure will
be set to an object of typeÂ <code>email</code>. But there is still a problem: the
defaut delegation strategy is not the one which is used in our method.
So we will give more information and tell the compiler (or the IDE) that
the delegation strategy is also changed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def email(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=EmailSpec) Closure cl) {
    def email = new EmailSpec()
    def code = cl.rehydrate(email, this, this)
    code.resolveStrategy = Closure.DELEGATE_ONLY
    code()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now, both the IDE and the type checker (if you are using <code>@TypeChecked</code>)
will be aware of the delegate and the delegation strategy. This is very
nice because it will both allow the IDE to provide smart completion, but
it will also remove errors at compile time that exist only because the
behaviour of the program is normally only known at runtime!</p>
</div>
<div class="paragraph">
<p>The following code will now pass compilation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@TypeChecked
void doEmail() {
    email {
        from 'dsl-guru@mycompany.com'
        to 'john.doe@waitaminute.com'
        subject 'The pope has resigned!'
        body {
            p 'Really, the pope has resigned!'
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="TheDelegatesToannotation-DelegatesTomodes">5.3. DelegatesTo modes</h3>
<div class="paragraph">
<p><code>@DelegatesTo</code> supports multiple modes that we will describe with examples
in this section.</p>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Simpledelegation">5.3.1. Simple delegation</h4>
<div class="paragraph">
<p>In this mode, the only mandatory parameter is theÂ <em>value</em> which says to
which class we delegate calls. Nothing more. Weâ€™re telling the compiler
that the type of the delegate willÂ <strong>always</strong> be of the type documented
byÂ <code>@DelegatesTo</code> (note that it can be a subclass, but if it is, the
methods defined by the subclass will not be visible to the type
checker).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">void body(@DelegatesTo(BodySpec) Closure cl) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Delegationstrategy">5.3.2. Delegation strategy</h4>
<div class="paragraph">
<p>In this mode, you must specify both the delegate classÂ <strong>and</strong> a
delegation strategy. This must be used if the closure will not be called
with the default delegation strategy, which isÂ <code>Closure.OWNER_FIRST</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">void body(@DelegatesTo(strategy=Closure.DELEGATE_ONLY, value=BodySpec) Closure cl) {
    // ...
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Delegatetoparameter">5.3.3. Delegate to parameter</h4>
<div class="paragraph">
<p>In this variant, we will tell the compiler that we are delegating to
another parameter of the method. Take the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def exec(Object target, Closure code) {
   def clone = code.rehydrate(target, this, this)
   clone()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Here, the delegate which will be used isÂ <strong>not</strong> created inside theÂ <code>exec</code>
method. In fact, we take an argument of the method and delegate to it.
Usage may look like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def email = new Email()
exec(email) {
   from '...'
   to '...'
   send()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each of the method calls are delegated to theÂ <code>email</code> parameter. This is
a widely used pattern which is also supported byÂ <code>@DelegatesTo</code> using a
companion annotation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def exec(@DelegatesTo.Target Object target, @DelegatesTo Closure code) {
   def clone = code.rehydrate(target, this, this)
   clone()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>A closure is annotated withÂ <code>@DelegatesTo</code>, but this time, without
specifying any class. Instead, weâ€™re annotating another parameter
withÂ <code>@DelegatesTo.Target</code>. The type of the delegate is then determined
at compile time. One could think that we are using the parameter type,
which in this case isÂ <code>Object</code> but this is not true. Take this code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Greeter {
   void sayHello() { println 'Hello' }
}
def greeter = new Greeter()
exec(greeter) {
   sayHello()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Remember that this works out of the boxÂ <strong>without</strong> having to annotate
withÂ <code>@DelegatesTo</code>. However, to make the IDE aware of the delegate
type, or theÂ <strong>type checker</strong> aware of it, we need to addÂ <code>@DelegatesTo</code>.
And in this case, it will now that theÂ <code>Greeter</code> variable is of
typeÂ <code>Greeter</code>, so it will not report errors on theÂ <em>sayHello</em>
methodÂ <strong>even if the exec method doesnâ€™t explicitely define the target as
of type Greeter</strong>. This is a very powerful feature, because it prevents
you from writing multiple versions of the sameÂ <code>exec</code> method for
different receiver types!</p>
</div>
<div class="paragraph">
<p>In this mode, theÂ <code>@DelegatesTo</code> annotation also supports theÂ <code>strategy</code>
parameter that weâ€™ve described upper.</p>
</div>
</div>
<div class="sect3">
<h4 id="TheDelegatesToannotation-Multipleclosures">5.3.4. Multiple closures</h4>
<div class="paragraph">
<p>In the previous example, theÂ <code>exec</code> method accepted only one closure,
but you may have methods that take multiple closures:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">void fooBarBaz(Closure foo, Closure bar, Closure baz) {
    ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then nothing prevents you from annotating each closure
withÂ <code>@DelegatesTo</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">class Foo { void foo(String msg) { println "Foo ${msg}!" } }
class Bar { void bar(int x) { println "Bar ${x}!" } }
class Baz { void baz(Date d) { println "Baz ${d}!" } }

void fooBarBaz(@DelegatesTo(Foo) Closure foo, @DelegatesTo(Bar) Closure bar, @DelegatesTo(Baz) Closure baz) {
   ...
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>But more importantly, if you have multiple closuresÂ <strong>and</strong> multiple
arguments, you can use several targets:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">void fooBarBaz(
    @DelegatesTo.Target('foo') foo,
    @DelegatesTo.Target('bar') bar,
    @DelegatesTo.Target('baz') baz,

    @DelegatesTo(target='foo') Closure cl1,
    @DelegatesTo(target='bar') Closure cl2,
    @DelegatesTo(target='baz') Closure cl3) {
    cl1.rehydrate(foo, this, this).call()
    cl2.rehydrate(bar, this, this).call()
    cl3.rehydrate(baz, this, this).call()
}

def a = new Foo()
def b = new Bar()
def c = new Baz()
fooBarBaz(
    a, b, c,
    { foo('Hello') },
    { bar(123) },
    { baz(new Date()) }
)</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
At this point, you may wonder why we donâ€™t use the parameter names as
references. The reason is that the information (the parameter name) is
not always available (itâ€™s a debug-only information), so itâ€™s a
limitation of the JVM.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_delegating_to_a_generic_type">5.3.5. Delegating to a generic type</h4>
<div class="paragraph">
<p>In some situations, it is interesting to instruct the IDE or the compiler that the delegate type will not be a parameter
but a generic type. Imagine a configurator that runs on a list of elements:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">public &lt;T&gt; void configure(List&lt;T&gt; elements, Closure configuration) {
   elements.each { e-&gt;
      def clone = configuration.rehydrate(e, this, this)
      clone.resolveStrategy = Closure.DELEGATE_FIRST
      clone.call()
   }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then this method can be called with any list like this:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.ToString
class Realm {
   String name
}
List&lt;Realm&gt; list = []
3.times { list &lt;&lt; new Realm() }
configure(list) {
   name = 'My Realm'
}
assert list.every { it.name == 'My Realm' }</code></pre>
</div>
</div>
<div class="paragraph">
<p>To let the type checker and the IDE know that the <code>configure</code> method calls the closure on each element of the list, you
 need to use <code>@DelegatesTo</code> differently:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">public &lt;T&gt; void configure(
    @DelegatesTo.Target List&lt;T&gt; elements,
    @DelegatesTo(strategy=Closure.DELEGATE_FIRST, genericTypeIndex=0) Closure configuration) {
   def clone = configuration.rehydrate(e, this, this)
   clone.resolveStrategy = Closure.DELEGATE_FIRST
   clone.call()
}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>@DelegatesTo</code> takes an optional <code>genericTypeIndex</code> argument that tells what is the index of the generic type that will
be used as the delegate type. This <strong>must</strong> be used in conjunction with <code>@DelegatesTo.Target</code> and the index starts at 0. In
the example above, that means that the delegate type is resolved against <code>List&lt;T&gt;</code>, and since the generic type at index
0 is <code>T</code> and inferred as a <code>Realm</code>, the type checker infers that the delegate type will be of type <code>Realm</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="icon-note" title="Note"></i>
</td>
<td class="content">
We&#8217;re using a <code>genericTypeIndex</code> instead of a placeholder (<code>T</code>) because of JVM limitations.
</td>
</tr>
</table>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="compilation-customizers">6. Compilation customizers</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_introduction">6.1. Introduction</h3>
<div class="paragraph">
<p>Whether you are usingÂ <code>groovyc</code> to compile classes or aÂ <code>GroovyShell</code>,
for example, to execute scripts, under the hood, a <em>compiler configuration</em> is used. This configuration holds information
like the source encoding or the classpath but it can also be used to perform more operations like adding imports by
default, applying AST transformations transparently or disabling global AST transformations.</p>
</div>
<div class="paragraph">
<p>The goal of compilation customizers is to make those common tasks easy to implement. For that, theÂ <code>CompilerConfiguration</code>
class is the entry point. The general schema will always be based on the following code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">import org.codehaus.groovy.control.CompilerConfiguration
// create a configuration
def config = new CompilerConfiguration()
// tweak the configuration
config.addCompilationCustomizers(...)
// run your script
def shell = new GroovyShell(config)
shell.evaluate(script)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Compilation customizers must extend theÂ <em>org.codehaus.groovy.control.customizers.CompilationCustomizer</em> class. A customizer works:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>on a specific compilation phase</p>
</li>
<li>
<p>onÂ <em>every</em> class node being compiled</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can implement your own compilation customizer but Groovy includes some of the most common operations.</p>
</div>
</div>
<div class="sect2">
<h3 id="_import_customizer">6.2. Import customizer</h3>
<div class="paragraph">
<p>Using this compilation customizer, your code will have imports added
transparently. This is in particular useful for scripts implementing a
DSL where you want to avoid users from having to write imports. The
import customizer will let you add all the variants of imports the
Groovy language allows, that is:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>class imports, optionally aliased</p>
</li>
<li>
<p>star imports</p>
</li>
<li>
<p>static imports, optionally aliased</p>
</li>
<li>
<p>static star imports</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">import org.codehaus.groovy.control.customizers.ImportCustomizer

def icz = new ImportCustomizer()
// "normal" import
icz.addImports('java.util.concurrent.atomic.AtomicInteger', 'java.util.concurrent.ConcurrentHashMap')
// "aliases" import
icz.addImport('CHM', 'java.util.concurrent.ConcurrentHashMap')
// "static" import
icz.addStaticImport('java.lang.Math', 'PI') // import static java.lang.Math.Pi
// "aliased static" import
icz.addStaticImport('pi', 'java.lang.Math', 'PI') // import static java.lang.Math.PI as pi
// "star" import
icz.addStarImports 'java.util.concurrent' // import java.util.concurrent.*
// "static star" import
icz.addStaticStars 'java.lang.Math' // import static java.lang.Math.*</code></pre>
</div>
</div>
<div class="paragraph">
<p>A detailed description of all shortcuts can be found in <a href='http://docs.groovy-lang.org/2.3.6/html/gapi/index.html?org/codehaus/groovy/control/customizers/ImportCustomizer.html' target='_blank'><code>org.codehaus.groovy.control.customizers.ImportCustomizer</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_ast_transformation_customizer">6.3. AST transformation customizer</h3>
<div class="paragraph">
<p>The AST transformation customizer is meant to apply AST transformations
transparently. Unlike global AST transformations that apply on every
class beeing compiled as long as the transform is found on classpath
(which has drawbacks like increasing the compilation time or side
effects due to transformations applied where they should not), the
customizer will allow you to selectively apply a transform only for
specific scripts or classes.</p>
</div>
<div class="paragraph">
<p>As an example, letâ€™s say you want to be able to useÂ <code>@Log</code> in a script.
The problem is thatÂ <code>@Log</code> is normally applied on a class node and a
script, by definition, doesnâ€™t require one. But implementation wise,
scripts are classes, itâ€™s just that you cannot annotate this implicit
class node withÂ <code>@Log</code>. Using the AST customizer, you have a workaround
to do it:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer
import groovy.util.logging.Log

def acz = new ASTTransformationCustomizer(Log)
config.addCompilationCustomizers(acz)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Thatâ€™s all! Internally, theÂ <code>@Log</code> AST transformation is applied to
every class node in the compilation unit. This means that it will be
applied to the script, but also to classes defined within the script.</p>
</div>
<div class="paragraph">
<p>If the AST transformation that you are using accepts parameters, you can
use parameters in the constructor too:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def acz = new ASTTransformationCustomizer(Log, value: 'LOGGER')
// use name 'LOGGER' instead of the default 'log'
config.addCompilationCustomizers(acz)</code></pre>
</div>
</div>
<div class="paragraph">
<p>As the AST transformation customizers works with objects instead of AST
nodes, not all values can be converted to AST transformation parameters.
For example, primitive types are converted toÂ <code>ConstantExpression</code> (that
is <code>LOGGER</code> is converted toÂ <code>new ConstantExpression('LOGGER')</code>, but if
your AST transformation takes a closure as an argument, then you have to
give it aÂ <code>ClosureExpression</code>, like in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def configuration = new CompilerConfiguration()
def expression = new AstBuilder().buildFromCode(CompilePhase.CONVERSION) { -&gt; true }.expression[0]
def customizer = new ASTTransformationCustomizer(ConditionalInterrupt, value: expression, thrown: SecurityException)
configuration.addCompilationCustomizers(customizer)
def shell = new GroovyShell(configuration)
shouldFail(SecurityException) {
    shell.evaluate("""
        // equivalent to adding @ConditionalInterrupt(value={true}, thrown: SecurityException)
        class MyClass {
            void doIt() { }
        }
        new MyClass().doIt()
    """)
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>For a complete list of options, please refer to <a href='http://docs.groovy-lang.org/2.3.6/html/gapi/index.html?org/codehaus/groovy/control/customizers/ASTTransformationCustomizer.html' target='_blank'><code>org.codehaus.groovy.control.customizers.ASTTransformationCustomizer</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_secure_ast_customizer">6.4. Secure AST customizer</h3>
<div class="paragraph">
<p>This customizer will allow the developer of a DSL to restrict the
<strong>grammar</strong> of the language, to prevent users from using some constructs,
for example. It is only &#8220;secure&#8221; in that sense only and it is very
important to understand that it doesÂ <strong>not</strong> replace a security manager.
The only reason for it to exist is to limit the expressiveness of the
language. This customizer only works at the AST (abstract syntax tree)
level, not at runtime! It can be strange at first glance, but it makes
much more sense if you think of Groovy as a platform to build DSLs. You
may not want a user to have a complete language at hand. In the example
below, we will demonstrate it using an example of language that only
allows arithmetic operations, but this customizer allows you to:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>allow/disallow creation of closures</p>
</li>
<li>
<p>allow/disallow imports</p>
</li>
<li>
<p>allow/disallow package definition</p>
</li>
<li>
<p>allow/disallow definition of methods</p>
</li>
<li>
<p>restrict the receivers of method calls</p>
</li>
<li>
<p>restrict the kind of AST expressions a user can use</p>
</li>
<li>
<p>restrict the tokens (grammar-wise) a user can use</p>
</li>
<li>
<p>restrict the types of the constants that can be used in code</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For all those features, the secure AST customizer works using either a
whitelist (list of elements that are allowed)Â <strong>or</strong> a blacklist (list of
elements that are disallowed). For each type of feature (imports,
tokens, â€¦) you have the choice to use either a whitelist or a blacklist,
but you can mix whitelists and blacklists for distinct features. In
general, you will choose whitelists (disallow all, allow selected).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">import org.codehaus.groovy.control.customizers.SecureASTCustomizer
import static org.codehaus.groovy.syntax.Types.* <i class="conum" data-value="1"></i><b>(1)</b>

def scz = new SecureASTCustomizer()
scz.with {
    closuresAllowed = false // user will not be able to write closures
    methodDefinitionAllowed = false // user will not be able to define methods
    importsWhitelist = [] // empty whitelist means imports are disallowed
    staticImportsWhitelist = [] // same for static imports
    staticStarImportsWhitelist = ['java.lang.Math'] // only java.lang.Math is allowed
    // the list of tokens the user can find
    // constants are defined in org.codehaus.groovy.syntax.Types
    tokensWhitelist = [ <i class="conum" data-value="1"></i><b>(1)</b>
            PLUS,
            MINUS,
            MULTIPLY,
            DIVIDE,
            MOD,
            POWER,
            PLUS_PLUS,
            MINUS_MINUS,
            COMPARE_EQUAL,
            COMPARE_NOT_EQUAL,
            COMPARE_LESS_THAN,
            COMPARE_LESS_THAN_EQUAL,
            COMPARE_GREATER_THAN,
            COMPARE_GREATER_THAN_EQUAL,
    ].asImmutable()
    // limit the types of constants that a user can define to number types only
    constantTypesClassesWhiteList = [ <i class="conum" data-value="2"></i><b>(2)</b>
            Integer,
            Float,
            Long,
            Double,
            BigDecimal,
            Integer.TYPE,
            Long.TYPE,
            Float.TYPE,
            Double.TYPE
    ].asImmutable()
    // method calls are only allowed if the receiver is of one of those types
    // be careful, it's not a runtime type!
    receiversClassesWhiteList = [ <i class="conum" data-value="2"></i><b>(2)</b>
            Math,
            Integer,
            Float,
            Double,
            Long,
            BigDecimal
    ].asImmutable()
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>use for token types from <a href='http://docs.groovy-lang.org/2.3.6/html/gapi/index.html?org/codehaus/groovy/syntax/Types.html' target='_blank'><code>org.codehaus.groovy.syntax.Types</code></a></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>you can use class literals here</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>If what the secure AST customizer provides out of the box isnâ€™t enough
for your needs, before creating your own compilation customizer, you
might be interested in the expression and statement checkers that the
AST customizer supports. Basically, it allows you to add custom checks
on the AST tree, on expressions (expression checkers) or statements
(statement checkers). For this, you must
implementÂ <code>org.codehaus.groovy.control.customizers.SecureASTCustomizer.StatementChecker</code>
orÂ <code>org.codehaus.groovy.control.customizers.SecureASTCustomizer.ExpressionChecker</code>.</p>
</div>
<div class="paragraph">
<p>Those interfaces define a single method calledÂ <code>isAuthorized</code>, returning
a boolean, and taking aÂ <code>Statement</code> (orÂ <code>Expression</code>) as a parameter. It
allows you to perform complex logic over expressions or statements to
tell if a user is allowed to do it or not.</p>
</div>
<div class="paragraph">
<p>For example, there&#8217;s no predefined configuration flag in the customizer which
will let you prevent people from using an attribute expression. Using a custom
checker, it is trivial:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">def scz = new SecureASTCustomizer()
def checker = { expr -&gt;
    !(expr instanceof AttributeExpression)
} as SecureASTCustomizer.ExpressionChecker
scz.addExpressionCheckers(checker)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then we can make sure that this works by evaluating a simple script:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">new GroovyShell(config).evaluate '''
    class A {
        int val
    }
    
    def a = new A(val: 123)
    a.@val <i class="conum" data-value="1"></i><b>(1)</b>
'''</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>will fail compilation</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Statements can be checked using <a href='http://docs.groovy-lang.org/2.3.6/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/StatementChecker.html' target='_blank'><code>org.codehaus.groovy.control.customizers.SecureASTCustomizer.StatementChecker</code></a>
Expressions can be checked using <a href='http://docs.groovy-lang.org/2.3.6/html/gapi/index.html?org/codehaus/groovy/control/customizers/SecureASTCustomizer/ExpressionChecker.html' target='_blank'><code>org.codehaus.groovy.control.customizers.SecureASTCustomizer.ExpressionChecker</code></a></p>
</div>
</div>
<div class="sect2">
<h3 id="_source_aware_customizer">6.5. Source aware customizer</h3>
<div class="paragraph">
<p>This customizer may be used as a filter on other customizers. The
filter, in that case, is theÂ <code>org.codehaus.groovy.control.SourceUnit</code>.
For this, the source aware customizer takes another customizer as a
delegate, and it will apply customization of that delegate only and only
if predicates on the source unit match.</p>
</div>
<div class="paragraph">
<p><code>SourceUnit</code> gives you access to multiple things but in particular the
file being compiled (if compiling from a file, of course). It gives
you the potential to perform operation based on the file name, for
example. Here is how you would create a source aware customizer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">import org.codehaus.groovy.control.customizers.SourceAwareCustomizer
import org.codehaus.groovy.control.customizers.ImportCustomizer

def delegate = new ImportCustomizer()
def sac = new SourceAwareCustomizer(delegate)</code></pre>
</div>
</div>
<div class="paragraph">
<p>Then you can use predicates on the source aware customizer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">// the customizer will only be applied to classes contained in a file name ending with 'Bean'
sac.baseNameValidator = { baseName -&gt;
    baseName.endsWith 'Bean'
}

// the customizer will only be applied to files which extension is '.spec'
sac.extensionValidator = { ext -&gt; ext == 'spec' }

// source unit validation
// allow compilation only if the file contains at most 1 class
sac.sourceUnitValidator = { SourceUnit sourceUnit -&gt; sourceUnit.AST.classes.size() == 1 }

// class validation
// the customizer will only be applied to classes ending with 'Bean'
sac.classValidator = { ClassNode cn -&gt; cn.endsWith('Bean') }</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_customizer_builder">6.6. Customizer builder</h3>
<div class="paragraph">
<p>If you are using compilation customizers in Groovy code (like the
examples above) then you can use an alternative syntax to customize compilation.
A builderÂ (<code>org.codehaus.groovy.control.customizers.builder.CompilerCustomizationBuilder</code>)
simplifies the creation of customizers using a hierarchical DSL.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">import org.codehaus.groovy.control.CompilerConfiguration
import static org.codehaus.groovy.control.customizers.builder.CompilerCustomizationBuilder.withConfig <i class="conum" data-value="1"></i><b>(1)</b>

def conf = new CompilerConfiguration()
withConfig(conf) {
    // ... <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>static import of the builder method</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>configuration goes here</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The code sample above shows how to use the builder. A static
method,Â <em>withConfig</em>, takes a closure corresponding to the builder code,
and automatically registers compilation customizers to the
configuration. Every compilation customizer available in the distribution
can be configured this way:</p>
</div>
<div class="sect3">
<h4 id="_import_customizer_2">6.6.1. Import customizer</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withConfig(configuration) {
   imports { // imports customizer
      normal 'my.package.MyClass' // a normal import
      alias 'AI', 'java.util.concurrent.atomic.AtomicInteger' // an aliased import
      star 'java.util.concurrent' // star imports
      staticMember 'java.lang.Math', 'PI' // static import
      staticMember 'pi', 'java.lang.Math', 'PI' // aliased static import
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ast_transformation_customizer_2">6.6.2. AST transformation customizer</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withConfig(conf) {
   ast(Log) <i class="conum" data-value="1"></i><b>(1)</b>
}

withConfig(conf) {
   ast(Log, value: 'LOGGER') <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>apply @Log transparently</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>apply @Log with a different name for the logger</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_secure_ast_customizer_2">6.6.3. Secure AST customizer</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withConfig(conf) {
   secureAst {
       closuresAllowed = false
       methodDefinitionAllowed = false
   }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_source_aware_customizer_2">6.6.4. Source aware customizer</h4>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withConfig(configuration){
    source(extension: 'sgroovy') {
        ast(CompileStatic) <i class="conum" data-value="1"></i><b>(1)</b>
    }
}

withConfig(configuration){
    source(extensions: ['sgroovy','sg']) {
        ast(CompileStatic) <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

withConfig(configuration) {
    source(extensionValidator: { it.name in ['sgroovy','sg']}) {
        ast(CompileStatic) <i class="conum" data-value="2"></i><b>(2)</b>
    }
}

withConfig(configuration) {
    source(basename: 'foo') {
        ast(CompileStatic) <i class="conum" data-value="3"></i><b>(3)</b>
    }
}

withConfig(configuration) {
    source(basenames: ['foo', 'bar']) {
        ast(CompileStatic) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}

withConfig(configuration) {
    source(basenameValidator: { it in ['foo', 'bar'] }) {
        ast(CompileStatic) <i class="conum" data-value="4"></i><b>(4)</b>
    }
}

withConfig(configuration) {
    source(unitValidator: { unit -&gt; !unit.AST.classes.any { it.name == 'Baz' } }) {
        ast(CompileStatic) <i class="conum" data-value="5"></i><b>(5)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>apply CompileStatic AST annotation on .sgroovy files</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>apply CompileStatic AST annotation on .sgroovy or .sg files</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>apply CompileStatic AST annotation on files whose name is <em>foo</em></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>apply CompileStatic AST annotation on files whose name is <em>foo</em> or <em>bar</em></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>apply CompileStatic AST annotation on files that do not contain a class named <em>Baz</em></td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_inlining_a_customizer">6.6.5. Inlining a customizer</h4>
<div class="paragraph">
<p>Inlined customizer allows you to write a compilation customizer
directly, without having to create a class for it.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withConfig(configuration) {
    inline(phase:'CONVERSION') { source, context, classNode -&gt;  <i class="conum" data-value="1"></i><b>(1)</b>
        println "visiting $classNode"                           <i class="conum" data-value="2"></i><b>(2)</b>
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>define an inlined customizer which will execute at the CONVERSION phase</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>prints the name of the class node being compiled</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="_multiple_customizers">6.6.6. Multiple customizers</h4>
<div class="paragraph">
<p>Of course, the builder allows you to define multiple customizers at
once:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withConfig(configuration) {
   ast(ToString)
   ast(EqualsAndHashCode)
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_config_script_flag">6.7. Config script flag</h3>
<div class="paragraph">
<p>So far, we have described how you can customize compilation using
aÂ <code>CompilationConfiguration</code> class, but this is only possible if you
embed Groovy and that you create your own instances
ofÂ <code>CompilerConfiguration</code> (then use it to create a
<code>GroovyShell</code>,Â <code>GroovyScriptEngine</code>, â€¦).</p>
</div>
<div class="paragraph">
<p>If you want it to be applied on the classes you compile with the normal
Groovy compiler (that is to say with Â <code>groovyc</code>,Â <code>ant</code> orÂ <code>gradle</code>,
for example), it is possible to use a compilation flag namedÂ <code>configscript</code>
that takes a Groovy configuration script as argument.</p>
</div>
<div class="paragraph">
<p>This script gives you access to theÂ <code>CompilerConfiguration</code> instanceÂ <strong>before</strong>
the files are compiled (exposed into the configuration script as a variable named <code>configuration</code>),
so that you can tweak it.</p>
</div>
<div class="paragraph">
<p>It also transparently integrates the compiler configuration builder above. As an example, let&#8217;s see
how you would activate static compilation by default on all classes.</p>
</div>
<div class="sect3">
<h4 id="_static_compilation_by_default">6.7.1. Static compilation by default</h4>
<div class="paragraph">
<p>Normally, classes in Groovy are compiled with a dynamic runtime. You can activate static compilation
by placing an annotation named <code>@CompileStatic</code> on any class. Some people would like to have this
mode activated by default, that is to say not having to annotated classes. Using <code>configscript</code>,
this is possible. First of all, you need to create a file named <code>config.groovy</code> into <code>src/conf</code> with
the following contents:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="prettyprint"><code class="groovy language-groovy">withConfig(configuration) { <i class="conum" data-value="1"></i><b>(1)</b>
   ast(groovy.transform.CompileStatic)
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><em>configuration</em> references a <code>CompilerConfiguration</code> instance</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>That is actually all you need. You donâ€™t have to import the builder, itâ€™s automatically
exposed in the script. Then, compile your files using the following command line:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>groovyc -configscript src/conf/config.groovy src/main/groovy/MyClass.groovy</pre>
</div>
</div>
<div class="paragraph">
<p>We strongly recommand you to separate configuration files from classes,
hence why we suggest using the <code>src/main</code> and <code>src/conf</code> directories above.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ast_transformations_tbd">6.8. AST transformations (TBD)</h3>

</div>
</div>
</div>
<div class="sect1">
<h2 id="_custom_type_checking_extensions_tbd">7. Custom type checking extensions (TBD)</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_builders_tbd">8. Builders (TBD)</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_creating_a_builder_tbd">8.1. Creating a builder (TBD)</h3>
<div class="sect3">
<h4 id="_buildersupport_tbd">8.1.1. BuilderSupport (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_factorybuildersupport_tbd">8.1.2. FactoryBuilderSupport (TBD)</h4>

</div>
</div>
<div class="sect2">
<h3 id="_existing_builders_tbd">8.2. Existing builders (TBD)</h3>
<div class="sect3">
<h4 id="_markupbuilder_tbd">8.2.1. MarkupBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_streamingmarkupbuilder_tbd">8.2.2. StreamingMarkupBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_saxbuilder_tbd">8.2.3. SaxBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_staxbuilder_tbd">8.2.4. StaxBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_dombuilder_tbd">8.2.5. DomBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_nodebuilder_tbd">8.2.6. NodeBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_jsonbuilder_tbd">8.2.7. JsonBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_streamingjsonbuilder_tbd">8.2.8. StreamingJsonBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_swingbuilder_tbd">8.2.9. SwingBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_antbuilder_tbd">8.2.10. AntBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_clibuilder_tbd">8.2.11. CliBuilder (TBD)</h4>

</div>
<div class="sect3">
<h4 id="_objectgraphbuilder_tbd">8.2.12. ObjectGraphBuilder (TBD)</h4>

</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Version 2.3.6<br>
Last updated 2014-07-28 15:13:29 CEST
</div>
</div>
</body>
</html>