<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8">

<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<meta name="generator" content="Asciidoctor 1.5.0.preview.7">

<title>Groovy语言文档</title>

<link rel="stylesheet" href="../assets/css/style.css">

<link rel="stylesheet" href="../font-awesome.min.css">

<link rel="stylesheet" href="../prettify.min.css">

<script src="../prettify.min.js"></script>

<script>document.addEventListener('DOMContentLoaded', prettyPrint)</script>

<link rel="stylesheet" href="../assets/css/view-example.css">

<script src='../assets/js/jquery-2.1.1.min.js'></script>

<script src='../assets/js/view-example.js'></script></head>

<body class="book toc2 toc-left">


<style type="text/css">#modify_div {opacity:0.6; position: fixed;right: 0px;top: 60px;	background-color: #000000;	

height: 30px;width: 100px;border-top-width: 2px;border-right-width: 2px;border-bottom-width: 2px;border-left-width: 2px;

border-top-style: dashed;border-right-style: none;border-bottom-style: dashed;border-left-style: dashed;border-top-color: #333333;

border-right-color: #333333;border-bottom-color: #333333;border-left-color: #333333;}

#modify {z-index:100;display: block;position: fixed;right: 23px;top: 70px;color: #FFFFFF;text-decoration: none;font-size: 12px;font-weight: bold;}

#modify:hover {text-decoration: underline;}</style><div id="modify_div"></div>

<a href="https://github.com/CnDoc/groovy-doc-cn/edit/gh-pages/cn/groovy_language_specification.html" id="modify" target="_blank">修改本页</a>


<div id="header">

<div id="toc" class="toc2">

<div id="toctitle">目录</div>


<ul class="sectlevel0">

	<li><a href="index.html">&lt;&lt;返回</a></li>

	<li>

		<ul class="sectlevel1">

			<li><a href="groovy_language_specification.html#_groovy_language_specification">1. Groovy语言规范</a></li>

			<li>

				<ul class="sectlevel2">

					<li><a href="groovy_language_specification.html#_syntax">1.1. 语法</a></li>

					<li>

						<ul class="sectlevel3">

							<li><a href="groovy_language_specification.html#_comments">1.1.1. 注释</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_single_line_comment">单行注释</a></li>

									<li><a href="groovy_language_specification.html#_multiline_comment">多行注释</a></li>

									<li><a href="groovy_language_specification.html#_groovydoc_comment">GroovyDoc注释</a></li>

									<li><a href="groovy_language_specification.html#_shebang_line">Shebang行</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_keywords">1.1.2. 关键字</a></li>

							<li><a href="groovy_language_specification.html#_identifiers">1.1.3. 标识符</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_normal_identifiers">普通标识符</a></li>

									<li><a href="groovy_language_specification.html#_quoted_identifiers">带引号标识符</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#all-strings">1.1.4. 字符串</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_single_quoted_string">单引号字符串</a></li>

									<li><a href="groovy_language_specification.html#_string_concatenation">字符串连接符</a></li>

									<li><a href="groovy_language_specification.html#_triple_single_quoted_string">三引号字符串</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_escaping_special_characters">转义特殊字符串</a></li>

											<li><a href="groovy_language_specification.html#_unicode_escape_sequence">Unicode转义序列</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_double_quoted_string">双引号字符串</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_string_interpolation">字符串插值</a></li>

											<li><a

												href="groovy_language_specification.html#_special_case_of_interpolating_closure_expressions">插值的特殊形式闭包表达式</a></li>

											<li><a href="groovy_language_specification.html#_inteoperability_with_java">与JAVA的互操作性</a></li>

											<li><a href="groovy_language_specification.html#_gstring_and_string_hashcodes">GString和String的hashCode</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_triple_double_quoted_string">三双引号字符串</a></li>

									<li><a href="groovy_language_specification.html#_slashy_string">斜杠字符串</a></li>

									<li><a href="groovy_language_specification.html#_dollar_slashy_string">美元符斜杠字符串</a></li>

									<li><a href="groovy_language_specification.html#_string_summary_table">字符串汇总表</a></li>

									<li><a href="groovy_language_specification.html#_characters">字符(Characters)</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_numbers">1.1.5. 数字</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_integral_literals">整型类型</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_alternative_non_base_10_representations">可选择的基于非10进制的表示</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a href="groovy_language_specification.html#_binary_literal">二进制</a></li>

													<li><a href="groovy_language_specification.html#_octal_literal">八进制</a></li>

													<li><a href="groovy_language_specification.html#_hexadecimal_literal">十六进制</a></li>

												</ul>

											</li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_decimal_literals">小数</a></li>

									<li><a href="groovy_language_specification.html#_underscore_in_literals">在数字中的下划线</a></li>

									<li><a href="groovy_language_specification.html#_number_type_suffixes">Number类型的后缀</a></li>

									<li><a href="groovy_language_specification.html#_math_operations">算术运算</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#integer_division">在除法运算的情况下</a></li>

											<li><a href="groovy_language_specification.html#power_operator">在幂运算的情况下</a></li>
											
											<li><a href="groovy_language_specification.html#integer_division">除法运算符的情况</a></li>

											<li><a href="groovy_language_specification.html#power_operator">幂运算符的情况</a></li>

										</ul>

									</li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_booleans">1.1.6. 布尔值</a></li>

							<li><a href="groovy_language_specification.html#_lists">1.1.7. 列表</a></li>

							<li><a href="groovy_language_specification.html#_arrays">1.1.8. 数组</a></li>

							<li><a href="groovy_language_specification.html#_maps">1.1.9. 映射（Maps）</a></li>

						</ul>

					</li>

					<li><a href="groovy_language_specification.html#groovy-operators">1.2. 运算符</a></li>

					<li>

						<ul class="sectlevel3">

							<li><a href="groovy_language_specification.html#_arithmetic_operators">1.2.1.

									算术运算符</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_normal_arithmetic_operators">常见算数运算符</a></li>

									<li><a href="groovy_language_specification.html#_unary_operators">单目运算符</a></li>

									<li><a href="groovy_language_specification.html#_assignment_arithmetic_operators">赋值算术运算符</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_relational_operators">1.2.2.

									关系运算符</a></li>

							<li><a href="groovy_language_specification.html#_logical_operators">1.2.3.

									逻辑运算符</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_precedence">优先级</a></li>

									<li><a href="groovy_language_specification.html#_short_circuiting_for_code_code">短路的(<code>||</code>)</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_bitwise_operators">1.2.4.

									位运算符</a></li>

							<li><a href="groovy_language_specification.html#_conditional_operators">1.2.5.

									条件运算符</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_not_operator">取反运算符</a></li>

									<li><a href="groovy_language_specification.html#_ternary_operator">三目运算符</a></li>

									<li><a href="groovy_language_specification.html#_elvis_operator">Elvis

											operator</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_object_operators">1.2.6. Object

									operators</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_safe_navigation_operator">Safe

											navigation operator</a></li>

									<li><a href="groovy_language_specification.html#_direct_field_access_operator">Direct

											field access operator</a></li>

									<li><a href="groovy_language_specification.html#_method_reference_operator">Method

											reference operator</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_regular_expression_operators">1.2.7.

									Regular expression operators</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_pattern_operator">Pattern

											operator</a></li>

									<li><a href="groovy_language_specification.html#_find_operator">Find operator</a></li>

									<li><a href="groovy_language_specification.html#_match_operator">Match

											operator</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_other_operators_wip">1.2.8.

									Other operators (WIP)</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_spread_operator">Spread

											operator</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_spreading_method_arguments">Spreading

													method arguments</a></li>

											<li><a href="groovy_language_specification.html#_spread_list_elements">Spread

													list elements</a></li>

											<li><a href="groovy_language_specification.html#_spread_map_elements">Spread

													map elements</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_range_operator">Range

											operator</a></li>

									<li><a href="groovy_language_specification.html#_spaceship_operator">Spaceship

											operator</a></li>

									<li><a href="groovy_language_specification.html#subscript-operator">Subscript

											operator</a></li>

									<li><a href="groovy_language_specification.html#_membership_operator">Membership

											operator</a></li>

									<li><a href="groovy_language_specification.html#_identity_operator">Identity

											operator</a></li>

									<li><a href="groovy_language_specification.html#_coercion_operator">Coercion

											operator</a></li>

									<li><a href="groovy_language_specification.html#_diamond_operator">Diamond

											operator</a></li>

									<li><a href="groovy_language_specification.html#_call_operator">Call operator</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_operator_precedence_tbd">1.2.9.

									Operator precedence (TBD)</a></li>

							<li><a href="groovy_language_specification.html#Operator-Overloading">1.2.10.

									Operator overloading</a></li>

						</ul>

					</li>

					<li><a href="groovy_language_specification.html#_program_structure_anto_aravinth">1.3.

							Program structure (Anto Aravinth)</a></li>

					<li>

						<ul class="sectlevel3">

							<li><a href="groovy_language_specification.html#_package_name_tbd">1.3.1.

									Package name (TBD)</a></li>

							<li><a href="groovy_language_specification.html#_imports_tbd">1.3.2. Imports

									(TBD)</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_default_imports_tbd">Default

											imports (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_simple_import_tbd">Simple

											import (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_star_import_tbd">Star import

											(TBD)</a></li>

									<li><a href="groovy_language_specification.html#_static_import_tbd">Static

											import (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_static_star_import_tbd">Static

											star import (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_import_aliasing_tbd">Import

											aliasing (TBD)</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_scripts_versus_classes">1.3.3.

									Scripts versus classes</a></li>

							<li><a href="groovy_language_specification.html#_imports">1.3.4. Imports</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_default_imports">Default

											imports</a></li>

									<li><a href="groovy_language_specification.html#_simple_import">Simple import</a></li>

									<li><a href="groovy_language_specification.html#_star_import">Star import</a></li>

									<li><a href="groovy_language_specification.html#_static_import">Static import</a></li>

									<li><a href="groovy_language_specification.html#_static_star_import">Static

											star import</a></li>

									<li><a href="groovy_language_specification.html#_import_aliasing">Import

											aliasing</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_initializers_tbd">1.3.5.

									Initializers (TBD)</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_static_initializers_tbd">Static

											initializers (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_instance_initializers_tbd">Instance

											initializers (TBD)</a></li>

								</ul>

							</li>

						</ul>

					</li>

					<li><a href="groovy_language_specification.html#_object_orientation">1.4. Object

							orientation</a></li>

					<li>

						<ul class="sectlevel3">

							<li><a href="groovy_language_specification.html#_types_tbd">1.4.1. Types (TBD)</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_primitive_types_tbd">Primitive

											types (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_class_tbd">Class (TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_normal_class_tbd">Normal

													class (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_static_class_tbd">Static

													class (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_inner_class_tbd">Inner

													class (TBD)</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a href="groovy_language_specification.html#_anonymous_inner_class_tbd">Anonymous

															inner class (TBD)</a></li>

												</ul>

											</li>

											<li><a href="groovy_language_specification.html#_abstract_class_tbd">Abstract

													class (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_interface_tbd">Interface

											(TBD)</a></li>

									<li><a href="groovy_language_specification.html#_annotation_tbd">Annotation

											(TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a

												href="groovy_language_specification.html#_closure_annotation_parameters_tbd">Closure

													annotation parameters (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_meta_annotations_tbd">Meta-annotations

													(TBD)</a></li>

											<li><a href="groovy_language_specification.html#_annotation_placement_tbd">Annotation

													placement (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_constructors_tbd">Constructors

											(TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_named_argument_constructor_tbd">Named

													argument constructor (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_methods_tbd">Methods (TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_method_definition_tbd">Method

													definition (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_named_arguments_tbd">Named

													arguments (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_default_arguments_tbd">Default

													arguments (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_varargs_tbd">Varargs (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_method_selection_algorithm_tbd">Method

													selection algorithm (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_exception_declaration_tbd">Exception

													declaration (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_fields_and_properties_tbd">Fields

											and properties (TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_fields_tbd">Fields (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_properties_tbd">Properties

													(TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_inheritance_tbd">Inheritance

											(TBD)</a></li>

									<li><a href="groovy_language_specification.html#generics">Generics (TBD)</a></li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_traits">1.4.2. Traits</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_methods">Methods</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_public_methods">Public

													methods</a></li>

											<li><a href="groovy_language_specification.html#_abstract_methods">Abstract

													methods</a></li>

											<li><a href="groovy_language_specification.html#_private_methods">Private

													methods</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_the_meaning_of_this">The

											meaning of this</a></li>

									<li><a href="groovy_language_specification.html#_interfaces">Interfaces</a></li>

									<li><a href="groovy_language_specification.html#_properties">Properties</a></li>

									<li><a href="groovy_language_specification.html#_fields">Fields</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_private_fields">Private

													fields</a></li>

											<li><a href="groovy_language_specification.html#_public_fields">Public

													fields</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_composition_of_behaviors">Composition

											of behaviors</a></li>

									<li><a href="groovy_language_specification.html#_overriding_default_methods">Overriding

											default methods</a></li>

									<li><a href="groovy_language_specification.html#_extending_traits">Extending

											traits</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_simple_inheritance">Simple

													inheritance</a></li>

											<li><a href="groovy_language_specification.html#_multiple_inheritance">Multiple

													inheritance</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_duck_typing_and_traits">Duck

											typing and traits</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_dynamic_code">Dynamic code</a></li>

											<li><a href="groovy_language_specification.html#_dynamic_methods_in_a_trait">Dynamic

													methods in a trait</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_multiple_inheritance_conflicts">Multiple

											inheritance conflicts</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_default_conflict_resolution">Default

													conflict resolution</a></li>

											<li><a href="groovy_language_specification.html#_user_conflict_resolution">User

													conflict resolution</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_runtime_implementation_of_traits">Runtime

											implementation of traits</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a

												href="groovy_language_specification.html#_implementing_a_trait_at_runtime">Implementing

													a trait at runtime</a></li>

											<li><a

												href="groovy_language_specification.html#_implementing_multiple_traits_at_once">Implementing

													multiple traits at once</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_chaining_behavior">Chaining

											behavior</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a

												href="groovy_language_specification.html#_semantics_of_super_inside_a_trait">Semantics

													of super inside a trait</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_advanced_features">Advanced

											features</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_sam_type_coercion">SAM type

													coercion</a></li>

											<li><a

												href="groovy_language_specification.html#_differences_with_java_8_default_methods">Differences

													with Java 8 default methods</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_differences_with_mixins">Differences

											with mixins</a></li>

									<li><a

										href="groovy_language_specification.html#_static_methods_properties_and_fields">Static

											methods, properties and fields</a></li>

									<li><a href="groovy_language_specification.html#_inheritance_of_state_gotchas">Inheritance

											of state gotchas</a></li>

									<li><a href="groovy_language_specification.html#_limitations">Limitations</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a

												href="groovy_language_specification.html#_compatibility_with_ast_transformations">Compatibility

													with AST transformations</a></li>

											<li><a href="groovy_language_specification.html#_prefix_and_postfix_operations">Prefix

													and postfix operations</a></li>

										</ul>

									</li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_closures_tbd">1.4.3. Closures

									(TBD)</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_syntax_tbd">Syntax (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_parameters_tbd">Parameters

											(TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_normal_parameters_tbd">Normal

													parameters (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_implicit_parameter_tbd">Implicit

													parameter (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_default_parameter_tbd">Default

													parameter (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_varargs_tbd_2">Varargs

													(TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_delegation_strategy_tbd">Delegation

											strategy (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_closures_in_gstrings_tbd">Closures

											in GStrings (TBD)</a></li>

									<li><a href="groovy_language_specification.html#_functional_programming_tbd">Functional

											programming (TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_currying_tbd">Currying

													(TBD)</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a href="groovy_language_specification.html#_left_currying_tbd">Left

															currying (TBD)</a></li>

													<li><a href="groovy_language_specification.html#_right_currying_tbd">Right

															currying (TBD)</a></li>

													<li><a href="groovy_language_specification.html#_index_based_currying_tbd">Index

															based currying (TBD)</a></li>

												</ul>

											</li>

											<li><a href="groovy_language_specification.html#_memoization_tbd">Memoization

													(TBD)</a></li>

											<li><a href="groovy_language_specification.html#_composition_tbd">Composition

													(TBD)</a></li>

											<li><a href="groovy_language_specification.html#_trampoline_tbd">Trampoline

													(TBD)</a></li>

										</ul>

									</li>

								</ul>

							</li>

							<li><a href="groovy_language_specification.html#_semantics">1.4.4. Semantics</a></li>

							<li>

								<ul class="sectlevel4">

									<li><a href="groovy_language_specification.html#_statements">Statements</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_variable_definition">Variable

													definition</a></li>

											<li><a href="groovy_language_specification.html#_variable_assignment">Variable

													assignment</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a href="groovy_language_specification.html#_multiple_assignment">Multiple

															assignment</a></li>

													<li><a href="groovy_language_specification.html#_overflow_and_underflow">Overflow

															and Underflow</a></li>

													<li><a

														href="groovy_language_specification.html#_object_destructuring_with_multiple_assignment">Object

															destructuring with multiple assignment</a></li>

												</ul>

											</li>

											<li><a href="groovy_language_specification.html#_control_structures_wip">Control

													structures (WIP)</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a href="groovy_language_specification.html#_conditional_structures">Conditional

															structures</a></li>

													<li>

														<ul class="sectlevel7">

															<li><a href="groovy_language_specification.html#_if_else">if / else</a></li>

															<li><a href="groovy_language_specification.html#_switch_case">switch /

																	case</a></li>

														</ul>

													</li>

													<li><a href="groovy_language_specification.html#_looping_structures">Looping

															structures</a></li>

													<li>

														<ul class="sectlevel7">

															<li><a href="groovy_language_specification.html#_classic_for_loop">Classic

																	for loop</a></li>

															<li><a href="groovy_language_specification.html#_for_in_loop">for in

																	loop</a></li>

															<li><a href="groovy_language_specification.html#_while_loop">while loop</a></li>

														</ul>

													</li>

													<li><a href="groovy_language_specification.html#_exception_handling">Exception

															handling</a></li>

													<li><a href="groovy_language_specification.html#_try_catch_finally">try /

															catch / finally</a></li>

													<li><a href="groovy_language_specification.html#_multi_catch">Multi-catch</a></li>

												</ul>

											</li>

											<li><a href="groovy_language_specification.html#_power_assertion_tbd">Power

													assertion (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_labeled_statements_tbd">Labeled

													statements (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_expressions_tbd">Expressions

											(TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_gpath_expressions_tbd">GPath

													expressions (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_promotion_and_coercion_tbd">Promotion

											and coercion (TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_number_promotion_tbd">Number

													promotion (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_closure_to_type_coercion">Closure

													to type coercion</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a

														href="groovy_language_specification.html#_assigning_a_closure_to_a_sam_type">Assigning

															a closure to a SAM type</a></li>

													<li><a

														href="groovy_language_specification.html#_calling_a_method_accepting_a_sam_type_with_a_closure">Calling

															a method accepting a SAM type with a closure</a></li>

													<li><a

														href="groovy_language_specification.html#_closure_to_arbitrary_type_coercion">Closure

															to arbitrary type coercion</a></li>

												</ul>

											</li>

											<li><a href="groovy_language_specification.html#_map_to_type_coercion">Map

													to type coercion</a></li>

											<li><a href="groovy_language_specification.html#_string_to_enum_coercion">String

													to enum coercion</a></li>

											<li><a href="groovy_language_specification.html#_custom_type_coercion">Custom

													type coercion</a></li>

											<li><a

												href="groovy_language_specification.html#_class_literals_vs_variables_and_the_as_operator">Class

													literals vs variables and the as operator</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_optionality_tbd">Optionality

											(TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_optional_parentheses_tbd">Optional

													parentheses (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_optional_semicolons_tbd">Optional

													semicolons (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_optional_return_keyword_tbd">Optional

													return keyword (TBD)</a></li>

											<li><a href="groovy_language_specification.html#_optional_public_keyword_tbd">Optional

													public keyword (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#Groovy-Truth">The Groovy Truth

											(TBD)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a

												href="groovy_language_specification.html#_customizing_the_truth_with_asboolean_methods_tbd">Customizing

													the truth with asBoolean() methods (TBD)</a></li>

										</ul>

									</li>

									<li><a href="groovy_language_specification.html#_typing_wip">Typing (WIP)</a></li>

									<li>

										<ul class="sectlevel5">

											<li><a href="groovy_language_specification.html#_optional_typing">Optional

													typing</a></li>

											<li><a href="groovy_language_specification.html#static-type-checking">Static

													type checking</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a

														href="groovy_language_specification.html#_the_code_typechecked_code_annotation">The

															<code>@TypeChecked</code> annotation

													</a></li>

													<li>

														<ul class="sectlevel7">

															<li><a

																href="groovy_language_specification.html#_activating_type_checking_at_compile_time">Activating

																	type checking at compile time</a></li>

															<li><a href="groovy_language_specification.html#_skipping_sections">Skipping

																	sections</a></li>

														</ul>

													</li>

													<li><a href="groovy_language_specification.html#_type_checking_assignments">Type

															checking assignments</a></li>

													<li><a href="groovy_language_specification.html#_list_and_map_constructors">List

															and map constructors</a></li>

													<li><a href="groovy_language_specification.html#_method_resolution">Method

															resolution</a></li>

													<li><a href="groovy_language_specification.html#type-inference">Type

															inference</a></li>

													<li>

														<ul class="sectlevel7">

															<li><a href="groovy_language_specification.html#_principles">Principles</a></li>

															<li><a

																href="groovy_language_specification.html#_variables_vs_fields_in_type_inference">Variables

																	vs fields in type inference</a></li>

															<li><a

																href="groovy_language_specification.html#_collection_literal_type_inference">Collection

																	literal type inference</a></li>

															<li><a href="groovy_language_specification.html#section-lub">Least upper

																	bound</a></li>

															<li><a href="groovy_language_specification.html#_instanceof_inference">instanceof

																	inference</a></li>

															<li><a href="groovy_language_specification.html#section-flow-typing">Flow

																	typing</a></li>

															<li><a href="groovy_language_specification.html#_advanced_type_inference">Advanced

																	type inference</a></li>

														</ul>

													</li>

													<li><a href="groovy_language_specification.html#_closures_and_type_inference">Closures

															and type inference</a></li>

													<li>

														<ul class="sectlevel7">

															<li><a href="groovy_language_specification.html#_return_type_inference">Return

																	type inference</a></li>

															<li><a href="groovy_language_specification.html#_parameter_type_inference">Parameter

																	type inference</a></li>

															<li>

																<ul class="sectlevel8">

																	<li><a

																		href="groovy_language_specification.html#_explicit_closure_parameters">Explicit

																			closure parameters</a></li>

																	<li><a

																		href="groovy_language_specification.html#_parameters_inferred_from_single_abstract_method_types">Parameters

																			inferred from single-abstract method types</a></li>

																	<li><a

																		href="groovy_language_specification.html#_the_code_closureparams_code_annotation">The

																			<code>@ClosureParams</code> annotation

																	</a></li>

																</ul>

															</li>

															<li><a href="groovy_language_specification.html#__code_delegatesto_code"><code>@DelegatesTo</code></a></li>

														</ul>

													</li>

												</ul>

											</li>

											<li><a href="groovy_language_specification.html#_static_compilation_wip">Static

													compilation (WIP)</a></li>

											<li>

												<ul class="sectlevel6">

													<li><a href="groovy_language_specification.html#_dynamic_vs_static">Dynamic

															vs static</a></li>

													<li><a href="groovy_language_specification.html#compilestatic-annotation">The

															<code>@CompileStatic</code> annotation

													</a></li>

													<li><a href="groovy_language_specification.html#_key_benefits">Key

															benefits</a></li>

												</ul>

											</li>

										</ul>

									</li>

								</ul>

							</li>

						</ul>

					</li>

				</ul>

			</li>


		</ul>

	</li>

</ul>












</div>

</div>

<div id="content">


<div class="sect1">

<h2 id="_groovy_language_specification">1. Groovy语言规范</h2>

<div class="sectionbody">

<div class="sect2">

<h3 id="_syntax">1.1. 语法</h3>

<div class="paragraph">

<p>本章将覆盖Groovy编程语言的语法。

Groovy语言的语法是由JAVA语言的语法衍生出来,

但具体结构上会有所增强，同时容许一定的简化。</p>

</div>

<div class="sect3">

<h4 id="_comments">1.1.1. 注释</h4>

<div class="sect4">

<h5 id="_single_line_comment">单行注释</h5>

<div class="paragraph">

<p>单行注释以<code>//</code>开始，同时它可以出现在行的任何地方。

在<code>//</code>之后的字符, 一直到行尾都是注释的部分。</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">// a standalone single line comment

println "hello" // a comment till the end of the line</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_multiline_comment">多行注释</h5>

<div class="paragraph">

<p>一个多行的注释以<code>/*</code>开头，同时它可以出现在行的任何地方。

在<code>/*</code>之后的字符将会被视作注释的一部分，包括新一行的字符, 直到第一个<code>*/</code>来结束注释。

多行注释因此可以被放到行尾，或者甚至在句子中间。</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">/* a standalone multiline comment

   spanning two lines */

println "hello" /* a multiline comment starting

                   at the end of a statement */

println 1 /* one */ + 2 /* two */</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_groovydoc_comment">GroovyDoc注释</h5>

<div class="paragraph">

<p>与多行注释类似，GroovyDoc注释是多行的，但是是以<code>/**</code>开始和以<code>*/</code>结尾。

在第一行GroovyDoc注释之后的行可以可选地以<code>*</code>开头。

这些注释的组成有：</p>

</div>

<div class="ulist">

<ul>

<li>

<p>类型定义（类，接口，枚举，注解），</p>

</li>

<li>

<p>字段和属性定义</p>

</li>

<li>

<p>方法定义</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>虽然编译器不会抱怨GroovyDoc注释没后包含上面的语言元素，但你应该在做注释之前预先考虑前面提到的这些结构。</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">/**

 * A Class description

 */

class Person {

    /** the name of the person */

    String name


    /**

     * Creates a greeting method for a certain person.

     *

     * @param otherPerson the person to greet

     * @return ag reeting message

     */

    String greet(String otherPerson) {

       "Hello ${otherPerson}"

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>GroovyDoc遵循与Java&#8217;s自带的JavaDoc一样的约定。

所以你可以使用于JavaDoc一样的标记。</p>

</div>

</div>

<div class="sect4">

<h5 id="_shebang_line">Shebang行</h5>

<div class="paragraph">

<p>除了单行注释外, 还有一种被特别的行注释, 通常被称作<em>shebang</em>行，它通常在UNIX系统中被认知，它容许脚本直接在命令行中运行那些你已经安装的Groovy和那些已经在<code>PATH</code>中可用的<code>groovy</code>命令。</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">#!/usr/bin/env groovy

println "Hello from the shebang line"</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

<code>#</code>字符必须是文件的第一个字符。 任何缩进都会引起一个编译错误。

</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_keywords">1.1.2. 关键字</h4>

<div class="paragraph">

<p>下面的列表列出了全部Groovy语言的关键字:</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<caption class="title">表1. 关键字</caption>

<colgroup>

<col style="width: 25%;">

<col style="width: 25%;">

<col style="width: 25%;">

<col style="width: 25%;">

</colgroup>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">as</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">assert</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">break</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">case</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">catch</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">class</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">const</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">continue</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">def</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">default</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">do</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">else</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">enum</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">extends</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">false</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">finally</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">for</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">goto</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">if</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">implements</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">import</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">in</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">instanceof</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">interface</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">new</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">null</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">package</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">return</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">super</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">switch</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">this</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">throw</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">throws</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">true</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">try</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">while</p></td>

</tr>

</tbody>

</table>

</div>

<div class="sect3">

<h4 id="_identifiers">1.1.3. 标识符</h4>

<div class="sect4">

<h5 id="_normal_identifiers">普通标识符</h5>

<div class="paragraph">

<p>标识符以字母，美元符或下划线开头。不能以数字开头</p>

</div>

<div class="paragraph">

<p>字母可以是以下的范围:</p>

</div>

<div class="ulist">

<ul>

<li>

<p><em>a</em> to <em>z</em> (小写 ascii 字母)</p>

</li>

<li>

<p><em>A</em> to <em>Z</em> (大写 ascii 字母)</p>

</li>

<li>

<p><em>\u00C0</em> to <em>\u00D6</em></p>

</li>

<li>

<p><em>\u00D8</em> to <em>\u00F6</em></p>

</li>

<li>

<p><em>\u00F8</em> to <em>\u00FF</em></p>

</li>

<li>

<p><em>\u0100</em> to <em>\uFFFE</em></p>

</li>

</ul>

</div>

<div class="paragraph">

<p>首字母之后的字符可以包含字母与数字。</p>

</div>

<div class="paragraph">

<p>这里有一些合法的表示符的例子(这是合法的名字):</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def name

def item3

def with_underscore

def $dollarStart</code></pre>

</div>

</div>

<div class="paragraph">

<p>但以下的是不合法的标识符:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def 3tier

def a+b

def a#b</code></pre>

</div>

</div>

<div class="paragraph">

<p>所有的跟着点号后关键字也是合法的标识符:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">foo.as

foo.assert

foo.break

foo.case

foo.catch</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_quoted_identifiers">带引号的标识符</h5>

<div class="paragraph">

<p>带引号标识符出现在点号表达式的点号之后。

例如，<code>person.name</code>表达式中<code>name</code>部分就可以引号引起来成为<code>person."name"</code>或<code>person.'name'</code>

有趣的是，当某些标识符包含由Java语言规范中禁止的非法字符，引号引起来后在Groovy就会被容许。

例如，像一个破折号，空格，感叹号等字符。</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def map = [:]


map."an identifier with a space and double quotes" = "ALLOWED"

map.'with-dash-signs-and-single-quotes' = "ALLOWED"


assert map."an identifier with a space and double quotes" == "ALLOWED"

assert map.'with-dash-signs-and-single-quotes' == "ALLOWED"</code></pre>

</div>

</div>

<div class="paragraph">

<p>

正如我们将会在<a href="groovy_language_specification.html#all-strings">strings</a>一节看到的那样，Groovy提供不同的字符串文字。

所有跟着点号的字符串都是被允许的：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">map.'single quote'

map."double quote"

map.'''triple single quote'''

map."""triple double quote"""

map./slashy string/

map.$/dollar slashy string/$</code></pre>

</div>

</div>

<div class="paragraph">

<p>

正如下面的例子，纯字符的字符串和Groovy的GStings（字符串插值）的区别是，计算整个标识符时，插入的字符值是被插入到最终字符串:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def firstname = "Homer"

map."Simson-${firstname}" = "Homer Simson"


assert map.'Simson-Homer' == "Homer Simson"</code></pre>

</div>

</div>

</div>

</div>

<div class="sect3">

<h4 id="all-strings">1.1.4. 字符串</h4>

<div class="paragraph">

<p>字符以链的形式形成的文本被称作字符串。

Groovy容许你实例化<code>java.lang.String</code>对象，以及在其他语言中被称作<em>插值字符串</em>（interpolated strings）的GStrings (<code>groovy.lang.GString</code>)</p>

</div>

<div class="sect4">

<h5 id="_single_quoted_string">单引号字符串</h5>

<div class="paragraph">

<p>单引号字符串是一系列被单引号引起来的字符：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def firstname = "Homer"

map."Simson-${firstname}" = "Homer Simson"


assert map.'Simson-Homer' == "Homer Simson"</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

单引号字符串是纯的<code>java.lang.String</code>，同时不支持插值。

</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_string_concatenation">字符串连接</h5>

<div class="paragraph">

<p>所有Groovy的字符串都可以用<code>+</code>号连接起来：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert 'ab' == 'a' + 'b'</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_triple_single_quoted_string">三引号字符串</h5>

<div class="paragraph">

<p>三引号字符串是一系列被单引号引起来的字符：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">'a single quoted string'</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

三引号字符串是纯的<code>java.lang.String</code>，同时不支持插值。

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>三引号字符串可以是多行的。

你不必将字符串分割成几块，也不必用连接符或换行符转义字符来将字符串跨行：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def aMultilineString = '''line one

line two

line three'''</code></pre>

</div>

</div>

<div class="paragraph">

<p>

如果你的代码是缩进的，比如在类里面的方法，你的字符串将会包含这些空白的缩进。

Groovy开发套件提供<code>String#stripIndent()</code>方法来剥离（stripping out）缩进，

同时Groovy开发套件提供<code>String#stripMargin()</code>方法，该方法需要一个分隔符来识别从字符串的开头开始删除的文本。</p>

</div>

<div class="paragraph">

<p>当创建如下的字符串时:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def startingAndEndingWithANewline = '''

line one

line two

line three

'''</code></pre>

</div>

</div>

<div class="paragraph">

<p>

你会发现，得到的是一个以换行符开头的字符串。可以通过反斜杠转义换行来剥离该字符：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def strippedFirstNewline = '''\

line one

line two

line three

'''


assert !strippedFirstNewline.startsWith('\n')</code></pre>

</div>

</div>

<div class="sect5">

<h6 id="_escaping_special_characters">转义特殊字符串</h6>

<div class="paragraph">

<p>你可以用反斜杠来转义单引号来避免终止字符串：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">'an escaped single quote: \' needs a backslash'</code></pre>

</div>

</div>

<div class="paragraph">

<p>同时你可以用两个反斜杠转义转义符号本身：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">'an escaped escape character: \\ needs a double backslash'</code></pre>

</div>

</div>

<div class="paragraph">

<p>一些特殊的字符串都是用反斜杠来作为转义字符：</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 33%;">

<col style="width: 66%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">转义序列</th>

<th class="tableblock halign-left valign-top">字符</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\t</em></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">制表键</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\b</em></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">后退键</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\n</em></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">换行</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\r</em></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">回车</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\f</em></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">换页</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\\</em></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">反斜杠</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\</em>'</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">单引号 (单引号和三单引号字符串)</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><em>\"</em></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">双引号(双引号和三双引号字符串)</p></td>

</tr>

</tbody>

</table>

</div>

<div class="sect5">

<h6 id="_unicode_escape_sequence">Unicode转义序列</h6>

<div class="paragraph">

<p>对于不存在你键盘上的字符，你可以使用Unicode转义序列：反斜杠，其次是<em>u</em>，然后4个十六进制数字。</p>

</div>

<div class="paragraph">

<p>例如，欧元货币符号可以表示为：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">'The Euro currency symbol: \u20AC'</code></pre>

</div>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_double_quoted_string">双引号字符串</h5>

<div class="paragraph">

<p>双引号字符串是一系列被双引号引起来的字符：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">"a double quoted string"</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

如果没有插值表示式的话，双引号字符串是纯的<code>java.lang.String</code>，

但如果有插值存在的话，双引号字符串就是一个<code>groovy.lang.GString</code>实例。

</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

为了转义一个双引号，你可以用反斜杠符号：<code>"A double quote: \""</code>.

</td>

</tr>

</table>

</div>

<div class="sect5">

<h6 id="_string_interpolation">字符串插值</h6>

<div class="paragraph">

<p>除了单引号和三引号字符串,任何Groovy表达式都可以插值到所有的字符串里。

插值就是当计算字符串的值时，用值替换掉字符串中的占位符。

占位符表达式是用<code>${}</code>围起来的，或者以<code>$</code>为前缀的点表达式。

当一个GString被传到一个需要字符串为参数的方法时，这个GString会调用<code>toString()</code>来计算自己的字符串值，这时字符串里面的占位符会计算为自己表达式值的字符串形式。</p>

</div>

<div class="paragraph">

<p>

在这里，我们有一个带占位符的字符串，这个占位符引用一个本地变量：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def name = 'Guillaume' // a plain string

def greeting = "Hello ${name}"


assert greeting.toString() == 'Hello Guillaume'</code></pre>

</div>

</div>

<div class="paragraph">

<p>然而任何的Groovy表达式都是有效的，正如我们看到的这个例子，它带有一个算术表达式:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def sum = "The sum of 2 and 3 equals ${2 + 3}"

assert sum.toString() == 'The sum of 2 and 3 equals 5'</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

不但表达式在<code>${}</code>占位符里面是合法的。语句也同样是合法的，但语句的值为<code>null</code>。

所以如果有多个语句在占位符里面，最后的那个语句应该返回一个有意义的值，以便替换整个占位符的值。

例如，

<code>"The sum of 1 and 2 is equal to ${def a = 1; def b = 2; a + b}"</code>是可以工作的，但一个好的做法通常是在GString里面的占位符内的表达式应该尽量简单。

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>除了<code>${}</code>占位符外，我们也可以用单一个<code>$</code>前缀符号的点表达式 ：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def person = [name: 'Guillaume', age: 36]

assert "$person.name is $person.age years old" == 'Guillaume is 36 years old'</code></pre>

</div>

</div>

<div class="paragraph">

<p>不单单<code>a.b</code>, <code>a.b.c</code>等点表达式是有效的， 

而且像方法这种带括号的表达式表达式，带大括号的闭包，或者算术运算符都是合法的。

给定以下这个定义为数字的变量：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def number = 3.14</code></pre>

</div>

</div>

<div class="paragraph">

<p>

下面的句子会抛出一个<code>groovy.lang.MissingPropertyException</code>异常，因为Groovy认为你试图访问这个数字的<code>toString</code>这个不存在的属性：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">shouldFail(MissingPropertyException) {

    println "$number.toString()"

}</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

你可以将<code>"$number.toString()"</code>想象为被解析器解释执行为<code>"${number.toString}()"</code>.

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>如果你想在GString转义<code>$</code>或<code>${}</code>以便不让他们显示为插值，

你只需要用反斜杠转义美元符号：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert '${name}' == "\${name}"</code></pre>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_special_case_of_interpolating_closure_expressions">插值的特殊形式闭包表达式</h6>

<div class="paragraph">

<p>

到目前为止，我们已经看到，我们可以插任意值到<code>${}</code>占位符，但这里有一个特殊情况就是闭包表达式。

当占位符包含一个箭头，<code>${&#8594;}</code>,这个表达式事实上是一个闭包表达式&#8201;&#8212;&#8201;你可以把它看作是一个带有美元符前缀的闭包：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def sParameterLessClosure = "1 + 2 == ${-&gt; 3}" <i class="conum" data-value="1"></i><b>(1)</b>

assert sParameterLessClosure == '1 + 2 == 3'


def sOneParamClosure = "1 + 2 == ${ w -&gt; w &lt;&lt; 3}" <i class="conum" data-value="2"></i><b>(2)</b>

assert sOneParamClosure == '1 + 2 == 3'</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>

这个闭包是一个不带参数的闭包。</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>

在这里，闭包接受一个<code>java.io.StringWriter</code>参数，你可以用<code>&lt;&lt;</code>左移运算符添加内容。

在那一个情况下，上面两个占位符都是嵌入的闭包。</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>

在表面上，这看起来像是一种更加详细定义插值的表达式，但比起其他普通的表达，闭包有一个有趣的优点：延时计算。</p>

</div>

<div class="paragraph">

<p>一起来考虑下以下的例子:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def number = 1 <i class="conum" data-value="1"></i><b>(1)</b>

def eagerGString = "value == ${number}"

def lazyGString = "value == ${ -&gt; number }"


assert eagerGString == "value == 1" <i class="conum" data-value="2"></i><b>(2)</b>

assert lazyGString ==  "value == 1" <i class="conum" data-value="3"></i><b>(3)</b>


number = 2 <i class="conum" data-value="4"></i><b>(4)</b>

assert eagerGString == "value == 1" <i class="conum" data-value="5"></i><b>(5)</b>

assert lazyGString ==  "value == 2" <i class="conum" data-value="6"></i><b>(6)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>

我们定义一个值为<code>1</code>的<code>number</code>类型变量，然后我们将它插值到两个GString，

<code>eagerGString</code>里使用表达式和<code>lazyGString</code>里使用闭包。

</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>我们期望<code>eagerGString</code>的结果字符串是包含字符串1的。</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>lazyGString</code>是相类似的方式。</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>这时我们用一个新的数字修改变量</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>

使用纯插值表达式的话，值实际上是被绑定到创建GString时候的值。</td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>

但使用闭包表达式的话，它是每次调用的时候都被强制将从GString转化为String，

结果给包含被更新的新数字值。</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

一个嵌入的闭包表达式接受多于一个参数的时候，将会在运行时产生一个异常。

闭包只接受零个或一个参数。

</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_inteoperability_with_java">与JAVA的互操作性</h6>

<div class="paragraph">

<p>当一个方法(无论是用JAVA实现还是Groovy实现)期望一个<code>java.lang.String</code>作为参数，
但我们传了一个<code>groovy.lang.GString</code>实例的时候，Gstring的<code>toString()</code>方法就会自动地，透明地被调用。
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String takeString(String message) {         <i class="conum" data-value="4"></i><b>(4)</b>

    assert message instanceof String        <i class="conum" data-value="5"></i><b>(5)</b>

    return message

}


def message = "The message is ${'hello'}"   <i class="conum" data-value="1"></i><b>(1)</b>

assert message instanceof GString           <i class="conum" data-value="2"></i><b>(2)</b>


def result = takeString(message)            <i class="conum" data-value="3"></i><b>(3)</b>

assert result instanceof String

assert result == 'The message is hello'</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>我们创建了一个GString变量</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>我们复查它的确是一个GString的实例</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>这时我们传递一个GString给一个接受String作为参数的方法</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td><code>takeString()</code>方法的签名明确的说明了它的唯一的一个参数是字符串类型</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>我们也验证参数确实是一个字符串，而不是一个GString。</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_gstring_and_string_hashcodes">GString和String的hashCode</h6>

<div class="paragraph">

<p>
虽然插值字符串可以被用来替代纯的Java字符串，
但它们有特别的方法来区分字符串：它们的hashcode是不同的。
纯Java字符串是不可变的，而GString表示的结果字符串却是可变的，这取决与它的插值。
即使是相同的结果字符串，GString和String的hasCode也是不同的。
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert "one: ${1}".hashCode() != "one: 1".hashCode()</code></pre>

</div>

</div>

<div class="paragraph">

<p>
GString和String有着不同的hasCode值，应该避免把GString用作Map的键，尤其是当我们尝试检索一个值时，应当使用String而不是GString。
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def key = "a"

def m = ["${key}": "letter ${key}"]     <i class="conum" data-value="1"></i><b>(1)</b>


assert m["a"] == null                   <i class="conum" data-value="2"></i><b>(2)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>map创建了一个以GString为键的键值对</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>当我们尝试用String类型键获取值的时候，我们将找不到, 因为String和GString有着不同的hashCode值</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_triple_double_quoted_string">三双引号字符串</h5>

<div class="paragraph">

<p>
三双引号字符串表现得像双引号字符串，只是它像三单引号字符串那样，是多行的。
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def name = 'Groovy'

def template = """

    Dear Mr ${name},


    You're the winner of the lottery!


    Yours sincerly,


    Dave

"""


assert template.toString().contains('Groovy')</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

在三双引号字符串里的，无论是双引号还是单引号都需要转义的。

</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_slashy_string">斜杠字符串</h5>

<div class="paragraph">

<p>
除了通常的带引号的字符串，Groovy提供斜杠字符串，它使用<code>/</code>作为分隔符。
斜杠字符串在定义正则表达式和模式的时候非常有用，因为不必要反斜杠来转义。</p>

</div>

<div class="paragraph">

<p>斜杠字符串的例子:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def fooPattern = /.*foo.*/

assert fooPattern == '.*foo.*'</code></pre>

</div>

</div>

<div class="paragraph">

<p>只有正斜杠需要用反斜杠转义:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def escapeSlash = /The character \/ is a forward slash/

assert escapeSlash == 'The character / is a forward slash'</code></pre>

</div>

</div>

<div class="paragraph">

<p>斜杠字符串可以是多行的：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def multilineSlashy = /one

    two

    three/


assert multilineSlashy.contains('\n')</code></pre>

</div>

</div>

<div class="paragraph">

<p>斜杠字符串也可以被插值（例如GString）：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def color = 'blue'

def interpolatedSlashy = /a ${color} car/


assert interpolatedSlashy == 'a blue car'</code></pre>

</div>

</div>

<div class="paragraph">

<p>有几个陷阱需要注意的。 </p>

</div>

<div class="paragraph">

<p>
一个空的斜杠字符串不可以用两个正斜杠来表示，因为它会被Groovy解析器理解为是一个行注释。
这就是以下的断言为什么实际上不会被编译，因为它看起像个还没结束的句子：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert '' == //</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_dollar_slashy_string">美元符斜杠字符串</h5>

<div class="paragraph">

<p>
美元符斜杠字符串是以<code>$/</code>开始和以<code>/$</code>结束的多行的GString。
转义的字符是美元符号，美元符号可以转义其他美元符号，或者正斜杠。
但美元符和正斜杠不是一定要去转义，
只要转义那些好像GString占位符那样以美元符开始的字符串，
或者那些以关闭美元斜杠字符串分割符号为开始的字符串。
</p>

</div>

<div class="paragraph">

<p>这里有一个例子：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def name = "Guillaume"

def date = "April, 1st"


def dollarSlashy = $/

    Hello $name,

    today we're ${date}.


    $ dollar sign

    $$ escaped dollar sign

    \ backslash

    / forward slash

    $/ escaped forward slash

    $/$ escaped dollar slashy string delimiter

/$


assert [

    'Guillaume',

    'April, 1st',

    '$ dollar sign',

    '$ escaped dollar sign',

    '\\ backslash',

    '/ forward slash',

        '$/ escaped forward slash',

        '/$ escaped dollar slashy string delimiter'


        ].each { dollarSlashy.contains(it) }</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_string_summary_table">字符串汇总表</h5>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 20%;">

<col style="width: 20%;">

<col style="width: 20%;">

<col style="width: 20%;">

<col style="width: 20%;">

</colgroup>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">字符串名</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">字符串语法</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">插值</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">多行</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">转义字符</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">单引号</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'&#8230;'</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check-empty"></i>否</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check-empty"></i>否</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">三单引号</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>'''&#8230;'''</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check-empty"></i>否</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">双引号</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"&#8230;"</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check-empty"></i>否</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">三双引号</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>"""&#8230;"""</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">斜杠</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/&#8230;/</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>\</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">美元符斜杠</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$/&#8230;/$</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="icon"><i class="icon-check"></i>是</span></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>$</code></p></td>

</tr>

</tbody>

</table>

</div>

<div class="sect4">

<h5 id="_characters">字符</h5>

<div class="paragraph">

<p>
与Java不同，Groovy中并没有一个明确的字符文字。
然而你可以有三种不同的方法，明确定义一个Groovy字符串使它实际上就是一字符:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">char c1 = 'A' <i class="conum" data-value="1"></i><b>(1)</b>
assert c1 instanceof Character

def c2 = 'B' as char <i class="conum" data-value="2"></i><b>(2)</b>
assert c2 instanceof Character

def c3 = (char)'C' <i class="conum" data-value="3"></i><b>(3)</b>
assert c3 instanceof Character</code></pre>
</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>
在声明变量的时候，通过显示声明<code>char</code>类型来指定它
</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>
使用<code>as</code>操作符来强制转换
</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>
使用chat操作符强制转换
</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">
当一个变量持有一个字符时，更倾向于第<em class="conum">1</em>种选择，
当一个字符值必须传给一个方法调用的时候，更倾向于其他两种(<em class="conum">2</em> and <em class="conum">3</em>)选择。
</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_numbers">1.1.5. 数字</h4>

<div class="paragraph">

<p>
Groovy支持不同种类整型和十进制文本，由Java的<code>Number</code>类型支持。
</p>

</div>

<div class="sect4">

<h5 id="_integral_literals">整型类型</h5>

<div class="paragraph">

<p>
整型类型与Java的是一样的：
</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>byte</code></p>

</li>

<li>

<p><code>char</code></p>

</li>

<li>

<p><code>short</code></p>

</li>

<li>

<p><code>int</code></p>

</li>

<li>

<p><code>long</code></p>

</li>

<li>

<p><code>java.lang.BigInteger</code></p>

</li>

</ul>

</div>

<div class="paragraph">

<p>
你可以用下面的声明创建这些类型的整数:
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">// 基本类型

byte  b = 1

char  c = 2

short s = 3

int   i = 4

long  l = 5


// 无限精度

BigInteger bi =  6</code></pre>

</div>

</div>

<div class="paragraph">

<p>
如果你使用<code>def</code>关键字来定义可选的类型，那么整型数字的类型就是可变的：
它能自行适配到合适的类型，以便能持有那个数字。
</p>

</div>

<div class="paragraph">

<p>对于正数:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def a = 1

assert a instanceof Integer


// Integer.MAX_VALUE

def b = 2147483647

assert b instanceof Integer


// Integer.MAX_VALUE + 1

def c = 2147483648

assert c instanceof Long


// Long.MAX_VALUE

def d = 9223372036854775807

assert d instanceof Long


// Long.MAX_VALUE + 1

def e = 9223372036854775808

assert e instanceof BigInteger</code></pre>

</div>

</div>

<div class="paragraph">

<p>
同样的对于负数：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def na = -1

assert na instanceof Integer


// Integer.MIN_VALUE

def nb = -2147483648

assert nb instanceof Integer


// Integer.MIN_VALUE - 1

def nc = -2147483649

assert nc instanceof Long


// Long.MIN_VALUE

def nd = -9223372036854775808

assert nd instanceof Long


// Long.MIN_VALUE - 1

def ne = -9223372036854775809

assert ne instanceof BigInteger</code></pre>

</div>

</div>

<div class="sect5">

<h6 id="_alternative_non_base_10_representations">可选择的基于非10进制的表示</h6>

<div class="sect6">

<h7 id="_binary_literal">二进制</h7>

<div class="paragraph">

<p>
在Java6和之前，以及在Groovy中，数字可以用十进制，八进制和十六进制来表示，
而在Java7和Groovy2，你可以使用带有<code>0b</code>前缀的二进制记数法：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int xInt = 0b10101111

assert xInt == 175


short xShort = 0b11001001

assert xShort == 201 as short


byte xByte = 0b11

assert xByte == 3 as byte


long xLong = 0b101101101101

assert xLong == 2925l


BigInteger xBigInteger = 0b111100100001

assert xBigInteger == 3873g


int xNegativeInt = -0b10101111

assert xNegativeInt == -175</code></pre>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_octal_literal">八进制</h7>

<div class="paragraph">

<p>八进制用<code>0</code>开头，后面跟八进制数字的经典模式来指定的。</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int xInt = 077

assert xInt == 63


short xShort = 011

assert xShort == 9 as short


byte xByte = 032

assert xByte == 26 as byte


long xLong = 0246

assert xLong == 166l


BigInteger xBigInteger = 01111

assert xBigInteger == 585g


int xNegativeInt = -077

assert xNegativeInt == -63</code></pre>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_hexadecimal_literal">十六进制</h7>

<div class="paragraph">

<p>
十六进制用<code>0x</code>开头，后面跟十六进制数字的经典模式来指定的。
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int xInt = 0x77

assert xInt == 119


short xShort = 0xaa

assert xShort == 170 as short


byte xByte = 0x3a

assert xByte == 58 as byte


long xLong = 0xffff

assert xLong == 65535l


BigInteger xBigInteger = 0xaaaa

assert xBigInteger == 43690g


Double xDouble = new Double('0x1.0p0')

assert xDouble == 1.0d


int xNegativeInt = -0x77

assert xNegativeInt == -119</code></pre>

</div>

</div>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_decimal_literals">小数</h5>

<div class="paragraph">

<p>小数类型与Java的一样：</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>float</code></p>

</li>

<li>

<p><code>double</code></p>

</li>

<li>

<p><code>java.lang.BigDecimal</code></p>

</li>

</ul>

</div>

<div class="paragraph">

<p>
你可以用以下声明来创建这些小数类型数字：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">// primitive types

float  f = 1.234

double d = 2.345


// infinite precision

BigDecimal bd =  3.456</code></pre>

</div>

</div>

<div class="paragraph">

<p>
小数可以使用指数，使用<code>e</code> or <code>E</code>的指数表示符，后跟一个可选的符号，和一个整数表示指数值：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert 1e3  ==  1_000.0

assert 2E4  == 20_000.0

assert 3e+1 ==     30.0

assert 4E-2 ==      0.04

assert 5e-1 ==      0.5</code></pre>

</div>

</div>

<div class="paragraph">

<p>
为了方便地进行精确的小数的计算，Groovy选择用<code>java.lang.BigDecimal</code>为小数的类型。
此外，无论是<code>float</code> 和 <code>double</code>都是被支持的，
但需要一个显示的类型声明，类型强制或后缀。
即使<code>BigDecimal</code>的是默认的小数类型，但这样的小数是可被用在以<code>float</code> 或 <code>double</code>作为参数的方法或闭包中的。
</p>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

小数不能使用二进制，八进制或十六进制表示形式来表示。

</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_underscore_in_literals">在数字中的下划线</h5>

<div class="paragraph">

<p>
当在输入一个很长的数字是，是很难看清楚这些数字的，
通过容许在数字之间输入下划线来分组，这样可以更容易分清楚这些数字:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">long creditCardNumber = 1234_5678_9012_3456L

long socialSecurityNumbers = 999_99_9999L

double monetaryAmount = 12_345_132.12

long hexBytes = 0xFF_EC_DE_5E

long hexWords = 0xFFEC_DE5E

long maxLong = 0x7fff_ffff_ffff_ffffL

long alsoMaxLong = 9_223_372_036_854_775_807L

long bytes = 0b11010010_01101001_10010100_10010010</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_number_type_suffixes">Number类型的后缀</h5>

<div class="paragraph">

<p>
我们可以用指定后缀（看下表）的方式强制指定一个数字的类型（包括二进制，八进制和十六进制），而这些后缀是不区分大小写的。
</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 33%;">

<col style="width: 66%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">类型</th>

<th class="tableblock halign-left valign-top">后缀</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>G</code> or <code>g</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>L</code> or <code>l</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>I</code> or <code>i</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>G</code> or <code>g</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>D</code> or <code>d</code></p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>F</code> or <code>f</code></p></td>

</tr>

</tbody>

</table>

<div class="paragraph">

<p>例子：</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert 42I == new Integer('42')

assert 42i == new Integer('42') // lowercase i more readable

assert 123L == new Long("123") // uppercase L more readable

assert 2147483648 == new Long('2147483648') // Long type used, value too large for an Integer

assert 456G == new BigInteger('456')

assert 456g == new BigInteger('456')

assert 123.45 == new BigDecimal('123.45') // default BigDecimal type used

assert 1.200065D == new Double('1.200065')

assert 1.234F == new Float('1.234')

assert 1.23E23D == new Double('1.23E23')

assert 0b1111L.class == Long // binary

assert 0xFFi.class == Integer // hexadecimal

assert 034G.class == BigInteger // octal</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_math_operations">算术运算</h5>

<div class="paragraph">

<p>
虽然<a href="groovy_language_specification.html#groovy-operators">操作符</a>将会在后面详细介绍，但讨论算术运算符的行为和运算结果的类型也是非常重要的。
</p>

</div>

<div class="paragraph">

<p>除了除法和指数这两个二元操作符外（后面将会介绍），</p>

</div>

<div class="ulist">

<ul>

<li>

<p>
<code>byte</code>, <code>char</code>, <code>short</code> 和 <code>int</code>之间的二元运算结果将会是<code>int</code></p>

</li>

<li>

<p>涉及到<code>long</code> 与 <code>byte</code>, <code>char</code>, <code>short</code> 和 <code>int</code> 的结果将会是 <code>long</code></p>

</li>

<li>

<p>涉及到 <code>BigInteger</code> 和其他整型类型的结果将会是<code>BigInteger</code></p>

</li>

<li>

<p><code>float</code>, <code>double</code> 和  <code>BigDecimal</code> 之间二元操作的结果将会是 <code>double</code></p>

</li>

<li>

<p>两个<code>BigDecimal</code>之间的二元操作结果将会是<code>BigDecimal</code></p>

</li>

</ul>

</div>

<div class="paragraph">

<p>下面的表格总结了这些规则：</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

<col style="width: 10%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top"></th>

<th class="tableblock halign-left valign-top">byte</th>

<th class="tableblock halign-left valign-top">char</th>

<th class="tableblock halign-left valign-top">short</th>

<th class="tableblock halign-left valign-top">int</th>

<th class="tableblock halign-left valign-top">long</th>

<th class="tableblock halign-left valign-top">BigInteger</th>

<th class="tableblock halign-left valign-top">float</th>

<th class="tableblock halign-left valign-top">double</th>

<th class="tableblock halign-left valign-top">BigDecimal</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>byte</strong></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>char</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>short</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>int</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">int</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>long</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">long</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>BigInteger</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigInteger</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>float</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>double</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">double</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>BigDecimal</strong></p></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">BigDecimal</p></td>

</tr>

</tbody>

</table>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">
得益于Groovy的操作符重载，常用的算术运算符一样可以用于<code>BigInteger</code> 和 <code>BigDecimal</code>之间，而不用好像Java那样你必须使用显式方法来操作这些数字。
</td>

</tr>

</table>

</div>

<div class="sect5">

<h6 id="integer_division">除法运算符的情况</h6>

<div class="paragraph">

<p>
如果其中一个操作数是<code>float</code>或<code>double</code>的话，除法运算<code>/</code> (和 <code>/=</code> 执行除法和指定)的结果将会是<code>double</code>，其他的都会是<code>BigDecimal</code>
（当操作数是<code>short</code>, <code>char</code>, <code>byte</code>, <code>int</code>, <code>long</code>,<code>BigInteger</code>或<code>BigDecimal</code>之间的任意组合）。
</p>

</div>

<div class="paragraph">

<p><code>BigDecimal</code> division is performed with the <code>divide()</code> method if the division is exact

(ie. yielding a result that can be represented within the bounds of the same precision and scale),

or using a <code>MathContext</code> with a <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#precision()">precision</a>

of the maximum of the two operands&#8217; precision plus an extra precision of 10,

and a <a href="http://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html#scale()">scale</a>

of the maximum of 10 and the maximum of the operands&#8217; scale.</p>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">
对于像Java中的整数除法，你应该使用<code>intdiv()</code>方法，而Groovy中并没有提供专用的整数除法运算符。
</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="power_operator">幂运算的情况下</h6>

<div class="paragraph">

<p>
幂运算是用<code>**</code>操作符表示，该操作符带有两个参数：底数和指数。
幂运算的结果过取决与他的操作数和运算的结果（尤其是如果结果可被表示为一个整数）
</p>

</div>

<div class="paragraph">

<p>
以下是Groovy的幂运算的规则，以确定结果类型：
</p>

</div>

<div class="ulist">

<ul>

<li>

<p>如果指数是一个十进制值</p>

<div class="ulist">

<ul>

<li>

<p>
如果结果可被表示为一个<code>Integer</code>，则返回一个<code>Integer</code> 
</p>

</li>

<li>

<p>
否则，如果结果可以表示为一个<code>Long</code>，然后返回一个<code>Long</code>
</p>

</li>

<li>

<p>
否则返回一个<code>Double</code>
</p>

</li>

</ul>

</div>

</li>

<li>

<p>如果指数为整数</p>

<div class="ulist">

<ul>

<li>

<p>
当指数为负，则返回一个<code>Integer</code>，<code>Long</code>或<code>Double</code>，这取决与结果值是否合适那个类型
</p>

</li>

<li>

<p>如果该指数是正数或零 </p>

<div class="ulist">

<ul>

<li>

<p>
如果底数是一个<code>BigDecimal</code>，则返回一个<code>BigDecimal</code>值的结果 
</p>

</li>

<li>

<p>
如果底数是一个<code>BigInteger</code>，然后返回一个<code>BigInteger</code>结果值 
</p>

</li>

<li>

<p>
如果底数是一个整数，而且结果可以放进一个<code>Integer</code>类型的话，就返回<code>Integer</code>，否则返回一个<code>BigInteger</code>
</p>

</li>

<li>

<p>
如果底数是一个<code>Long</code>，而且结果可以放进一个<code>Long</code>类型的话，就返回<code>Long</code>,否则返回一个<code>BigInteger</code>
</p>

</li>

</ul>

</div>

</li>

</ul>

</div>

</li>

</ul>

</div>

<div class="paragraph">

<p>
我们可以用一些举例来说明这些规则：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">// base and exponent are ints and the result can be represented by an Integer

assert    2    **   3    instanceof Integer    //  8

assert   10    **   9    instanceof Integer    //  1_000_000_000


// the base is a long, so fit the result in a Long

// (although it could have fit in an Integer)

assert    5L   **   2    instanceof Long       //  25


// the result can't be represented as an Integer or Long, so return a BigInteger

assert  100    **  10    instanceof BigInteger //  10e20

assert 1234    ** 123    instanceof BigInteger //  170515806212727042875...


// the base is a BigDecimal and the exponent a negative int

// but the result can be represented as an Integer

assert    0.5  **  -2    instanceof Integer    //  4


// the base is an int, and the exponent a negative float

// but again, the result can be represented as an Integer

assert    1    **  -0.3f instanceof Integer    //  1


// the base is an int, and the exponent a negative int

// but the result will be calculated as a Double

// (both base and exponent are actually converted to doubles)

assert   10    **  -1    instanceof Double     //  0.1


// the base is a BigDecimal, and the exponent is an int, so return a BigDecimal

assert    1.2  **  10    instanceof BigDecimal //  6.1917364224


// the base is a float or double, and the exponent is an int

// but the result can only be represented as a Double value

assert    3.4f **   5    instanceof Double     //  454.35430372146965

assert    5.6d **   2    instanceof Double     //  31.359999999999996


// the exponent is a decimal value

// and the result can only be represented as a Double value

assert    7.8  **   1.9  instanceof Double     //  49.542708423868476

assert    2    **   0.1f instanceof Double     //  1.0717734636432956</code></pre>

</div>

</div>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_booleans">1.1.6. Booleans</h4>

<div class="paragraph">

<p>
布尔值是用来表示真值的特殊数据类型：<code>true</code>和<code>false</code>。
可使用这种数据类型，简单地跟踪真/假的<a href="groovy_language_specification.html#_conditional_operators">条件（conditions）</a>。
</p>

</div>

<div class="paragraph">

<p>
布尔值就像任何其他数据类型一样，可以存储在变量中，可以被指派到字段，：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def myBooleanVariable = true

boolean untypedBooleanVar = false

booleanField = true</code></pre>

</div>

</div>

<div class="paragraph">

<p>
<code>true</code>和<code>false</code>是仅有的两个布尔值基元。
但更复杂的布尔表达式可以使用<a href="groovy_language_specification.html#_bitwise_and_logical_operators">逻辑运算符</a>来表示。 
</p>

</div>

<div class="paragraph">

<p>
此外，Groovy中具有强制非布尔对象转化为布尔值的<a href="groovy_language_specification.html#_the_groovy_truth">特殊规则</a>（通常被称为<em>Groovy Truth</em>）。
</p>

</div>

</div>

<div class="sect3">

<h4 id="_lists">1.1.7. 列表</h4>

<div class="paragraph">

<p>
Groovy使用逗号分割列表的值，使用方括号括起，来表示列表。
Groovy列表是普通的JDK<code>java.util.List</code>，因为Groovy中没有定义自己的集合类。
在默认情况下，定义列表的实现具体类是<code>java.util.ArrayList</code>，除非你决定自己指定，正如我们将在后面看到的。
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def numbers = [1, 2, 3]         <i class="conum" data-value="1"></i><b>(1)</b>


assert numbers instanceof List  <i class="conum" data-value="2"></i><b>(2)</b>

assert numbers.size() == 3      <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>
我们用逗号分割和方括号括起来的方法定义一个数字列表，同时我们指派这个列表到一个变量
</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>
这个列表是Java的<code>java.util.List</code>接口的一个实例
</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>
列表的长度可以用<code>size()</code>方法来查询，它显示列表包含3个元素
</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>
在上面的例子，我们使用了一个同质列表，但你也可以创建一个包含异构类型的值列表：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def heterogeneous = [1, "a", true]  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>
我们的列表包含了一个数字，一个字符串和一个布尔值
</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>
我们提到，在默认情况下，列表实际上是<code>java.util.ArrayList</code>的实例，
但我们的列表使用不同的类型，
这得益于我们可以使用<code>as</code>操作符号强制类型转换，或者显式类型声明的变量：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def arrayList = [1, 2, 3]

assert arrayList instanceof java.util.ArrayList


def linkedList = [2, 3, 4] as LinkedList    <i class="conum" data-value="1"></i><b>(1)</b>

assert linkedList instanceof java.util.LinkedList


LinkedList otherLinked = [3, 4, 5]          <i class="conum" data-value="2"></i><b>(2)</b>

assert otherLinked instanceof java.util.LinkedList</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>
我们使用<code>as</code>操作符强制明确要求一个<code>java.util.LinkedList</code>的实现
</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>
我们可以声明一个变量持有的列表是<code>java.util.LinkedList</code>类型的。
</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>
你可以用<code>[]</code>下标操作符访问列表的元素（读写值均可），
使用正数从头访问，或负数从列表的尾部访问元素，也可以使用范围，
也可以用<code>&lt;&lt;</code>左移操作符号来添加一个元素到列表：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def letters = ['a', 'b', 'c', 'd']


assert letters[0] == 'a'     <i class="conum" data-value="1"></i><b>(1)</b>

assert letters[1] == 'b'


assert letters[-1] == 'd'    <i class="conum" data-value="2"></i><b>(2)</b>

assert letters[-2] == 'c'


letters[2] = 'C'             <i class="conum" data-value="3"></i><b>(3)</b>

assert letters[2] == 'C'


letters &lt;&lt; 'e'               <i class="conum" data-value="4"></i><b>(4)</b>

assert letters[ 4] == 'e'

assert letters[-1] == 'e'


assert letters[1, 3] == ['b', 'd']         <i class="conum" data-value="5"></i><b>(5)</b>

assert letters[2..4] == ['C', 'd', 'e']    <i class="conum" data-value="6"></i><b>(6)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>
访问列表的第一个元素（由0来是算起）
</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>
用一个负数索引来访问最尾的元素：-1是从尾部算起的第一个元素
</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>
使用等号来设置一个新的值到列表的第三个元素
</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>
使用<code>&lt;&lt;</code>左移动操作符添加一个元素到列表的最后
</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>
一次访问两个元素，返回一个包含这两个元素的新列表
</td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>
使用一个从开始到结束元素的位置的范围来访问列表的一个范围内的值。
</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>
如列表可以是异构性质的，列表还可以包含其他的列表来创建多维表：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def multi = [[0, 1], [2, 3]]     <i class="conum" data-value="1"></i><b>(1)</b>

assert multi[1][0] == 2          <i class="conum" data-value="2"></i><b>(2)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>定义一个以列表作为元素的列表</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>
访问最上面列表中的第二个元素同时是内部列表中的第一个元素的元素
</td>

</tr>

</table>

</div>

</div>

<div class="sect3">

<h4 id="_arrays">1.1.8. 数组</h4>

<div class="paragraph">

<p>
Groovy中重用列表符号表示数组，但创建这样的文字数组，你需要通过强制或类型声明，明确地定义数组类型。 
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String[] arrStr = ['Ananas', 'Banana', 'Kiwi']  <i class="conum" data-value="1"></i><b>(1)</b>


assert arrStr instanceof String[]    <i class="conum" data-value="2"></i><b>(2)</b>

assert !(arrStr instanceof List)     <i class="conum" data-value="3"></i><b>(3)</b>


def numArr = [1, 2, 3] as int[]      <i class="conum" data-value="4"></i><b>(4)</b>


assert numArr instanceof int[]       <i class="conum" data-value="5"></i><b>(5)</b>

assert numArr.size() == 3</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>
使用明确的变量类型声明定义一个字符串数组
</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>断言我们建立了一个字符串数字</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>
使用<code>as</code>操作符创建一个int数组
</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>
断言我们创建了原始类型的int数组
</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>您还可以创建多维数组:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def matrix3 = new Integer[3][3]         <i class="conum" data-value="1"></i><b>(1)</b>

assert matrix3.size() == 3


Integer[][] matrix2                     <i class="conum" data-value="2"></i><b>(2)</b>

matrix2 = [[1, 2], [3, 4]]

assert matrix2 instanceof Integer[][]</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>你可以定义一个新的数组的边界</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>或声明数组时没有指定界限</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>
访问数组中的元素遵循与操作列表使用相同的符号：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String[] names = ['Cédric', 'Guillaume', 'Jochen', 'Paul']

assert names[0] == 'Cédric'     <i class="conum" data-value="1"></i><b>(1)</b>


names[2] = 'Blackdrag'          <i class="conum" data-value="2"></i><b>(2)</b>

assert names[2] == 'Blackdrag'</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>检索数组的第一元素</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>
设置一个新值到数组的第三个元素
</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">
Groovy不支持Java的数组初始符号，而大括号可能被误解为Groovy闭包的符号。
</td>

</tr>

</table>

</div>

</div>

<div class="sect3">

<h4 id="_maps">1.1.9. 映射（Maps）</h4>

<div class="paragraph">

<p>
在其他语言中有时也被称为字典或关联数组的特性在Groovy称为映射（maps）。 
映射（maps）关联键到值，用冒号来分隔键到值，用逗号分割每对键值对，同时用方括号把整个键值包起来。
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def colors = [red: '#FF0000', green: '#00FF00', blue: '#0000FF']   <i class="conum" data-value="1"></i><b>(1)</b>


assert colors['red'] == '#FF0000'    <i class="conum" data-value="2"></i><b>(2)</b>

assert colors.green  == '#00FF00'    <i class="conum" data-value="3"></i><b>(3)</b>


colors['pink'] = '#FF00FF'           <i class="conum" data-value="4"></i><b>(4)</b>

colors.yellow  = '#FFFF00'           <i class="conum" data-value="5"></i><b>(5)</b>


assert colors.pink == '#FF00FF'

assert colors['yellow'] == '#FFFF00'


assert colors instanceof java.util.LinkedHashMap</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>
我们定义了一个颜色名字和他们十六进制编码的html颜色相关联的映射
</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>
我们使用下标符号来检索与<code>red</code>键关联的内容 
</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>
我们也可以使用属性表示法来断言绿色的十六进制表示
</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>
相似地，我们可以使用下标符号添加新的键/值对
</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>或者属性访问符来添加<code>yellow</code>颜色</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">
当使用该键的名字时，我们实质上是定义在映射中定义字符串键。
</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">
Groovy建立的maps实际上是<code>java.util.LinkedHashMap</code>的实例。
Groovy creates maps that are actually instances of <code>java.util.LinkedHashMap</code>.
</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>
如果你尝试用一个不存在的健来访问map:
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert colors.unknown == null</code></pre>

</div>

</div>

<div class="paragraph">

<p>你将会获得一个<code>null</code>结果。</p>

</div>

<div class="paragraph">

<p>
在上面的例子，我们使用的是字符串的键，但你也可以使用其他类型的值来作为键：
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def numbers = [1: 'one', 2: 'two']


assert numbers[1] == 'one'</code></pre>

</div>

</div>

<div class="paragraph">

<p>
这里我们使用数字作为键，因为数字可以清楚地被识别为数字， 
所以Groovy中不会产生像在我们前面的例子中一个字符串键。
但考虑下当你想传递一个变量代替键的情况，你希望这个变量的值能成为键： 
</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def key = 'name'

def person = [key: 'Guillaume']      <i class="conum" data-value="1"></i><b>(1)</b>


assert !person.containsKey('name')   <i class="conum" data-value="2"></i><b>(2)</b>

assert person.containsKey('key')     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>The <code>key</code> associated with the <code>'Guillaume&#8217;</code> name will actually be the <code>"key"</code> string, not the value associated with the <code>key</code> variable</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>The map doesn&#8217;t contain the <code>'name&#8217;</code> key</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>Instead, the map contains a <code>'key&#8217;</code> key</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

You can also pass quoted strings as well as keys: <code>["name": "Guillaume"]</code>.

This is mandatory if your key string isn&#8217;t a valid identifier,

for example if you wanted to create a string key containing a hash like in: <code>["street-name": "Main street"]</code>.

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>When you need to pass variable values as keys in your map definitions, you must surround the variable or expression with parentheses:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">person = [(key): 'Guillaume']        <i class="conum" data-value="1"></i><b>(1)</b>


assert person.containsKey('name')    <i class="conum" data-value="2"></i><b>(2)</b>

assert !person.containsKey('key')    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>This time, we surround the <code>key</code> variable with parentheses, to instruct the parser we are passing a variable rather than defining a string key</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>The map does contain the <code>name</code> key</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>But the map doesn&#8217;t contain the <code>key</code> key as before</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect2">

<h3 id="groovy-operators">1.2. 运算符</h3>

<div class="paragraph">

<p>本章涵盖了Groovy的所有运算符.</p>

</div>

<div class="sect3">

<h4 id="_arithmetic_operators">1.2.1. 算术运算符</h4>

<div class="paragraph">

<p>Groovy支持在数学和其他编程语言如Java中常见的算术运算符.Java中所有的算术运算符都能够被支持.让我们通过随后的例子来认识他们.</p>

</div>

<div class="sect4">

<h5 id="_normal_arithmetic_operators">常见算术运算符</h5>

<div class="paragraph">

<p>下列的二进制算术运算符在Groovy中是有效的:</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 33%;">

<col style="width: 33%;">

<col style="width: 33%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">运算符</th>

<th class="tableblock halign-left valign-top">作用</th>

<th class="tableblock halign-left valign-top">备注</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">加</p></td>

<td class="tableblock halign-left valign-top"></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">减</p></td>

<td class="tableblock halign-left valign-top"></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">乘</p></td>

<td class="tableblock halign-left valign-top"></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">除</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>intdiv()</code>用于整数除法，在这里<a href="core-syntax.html#integer_division">the integer division</a>可以看到更多关于除法的返回类型的信息.</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">模</p></td>

<td class="tableblock halign-left valign-top"></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"> 幂</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">
在这里<a href="core-syntax.html#power_operator">the power operation</a>可以看到更多关于运算符返回类型的信息.</p></td>

</tr>

</tbody>

</table>

<div class="paragraph">

<p>这里有几个使用这些运算符的示例:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert  1  + 2 == 3

assert  4  - 3 == 1

assert  3  * 5 == 15

assert  3  / 2 == 1.5

assert 10  % 3 == 1

assert  2 ** 3 == 8</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_unary_operators">一元运算符</h5>

<div class="paragraph">

<p><code>+</code>和<code>-</code>也可以用作一元运算符:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert +3 == 3

assert -4 == 0 - 4


assert -(-1) == 1  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>Note the usage of parentheses to surround an expression to apply the unary minus to that surrounded expression.</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>依据一元算术表达式，<code>++</code>(叠加)和<code>--</code>(叠减)是有效的，无论是前缀符号还是后缀符号:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def a = 2

def b = a++ * 3             <i class="conum" data-value="1"></i><b>(1)</b>


assert a == 3 &amp;&amp; b == 6


def c = 3

def d = c-- * 2             <i class="conum" data-value="2"></i><b>(2)</b>


assert c == 2 &amp;&amp; d == 6


def e = 1

def f = ++e + 3             <i class="conum" data-value="3"></i><b>(3)</b>


assert e == 2 &amp;&amp; f == 5


def g = 4

def h = --g + 1             <i class="conum" data-value="4"></i><b>(4)</b>


assert g == 3 &amp;&amp; h == 4</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>后缀<code>++</code>将会在<code>a</code>执行和分配完值到<code>b</code>中之后自增1.</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>后缀<code>--</code>将会在<code>c</code>执行和分配完值到<code>d</code>中之后自减1.</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>前缀<code>++</code>将会在<code>e</code>执行和分配值到<code>f</code>中之前自加1.</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>前缀<code>--</code>将会在<code>g</code>执行和分配值到<code>h</code>中之前自减1.</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_assignment_arithmetic_operators">赋值运算符</h5>

<div class="paragraph">

<p>如上所见的二进制算术运算符，如下一些写法同样是有效的：</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>+=</code></p>

</li>

<li>

<p><code>-=</code></p>

</li>

<li>

<p><code>*=</code></p>

</li>

<li>

<p><code>/=</code></p>

</li>

<li>

<p><code>%=</code></p>

</li>

</ul>

</div>

<div class="paragraph">

<p>实际使用示例:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def a = 4

a += 3


assert a == 7


def b = 5

b -= 3


assert b == 2


def c = 5

c *= 3


assert c == 15


def d = 10

d /= 2


assert d == 5


def e = 10

e %= 3


assert e == 1</code></pre>

</div>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_relational_operators">1.2.2. 关系运算符</h4>

<div class="paragraph">

<p>关系运算符允许对象之间比较，从而知道两个对象是相同还是不同,一个是大于还是小于或等于另一个.</p>

</div>

<div class="paragraph">

<p>下列运算符是有效的:</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 50%;">

<col style="width: 50%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">运算符</th>

<th class="tableblock halign-left valign-top">作用</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>==</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">相等</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>!=</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">不等</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">小于</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;=</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">小于或等于</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">大于</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;=</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">大于或等于</p></td>

</tr>

</tbody>

</table>

<div class="paragraph">

<p>如下是这些运算符在简单数字上的使用:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert 1 + 2 == 3

assert 3 != 4


assert -2 &lt; 3

assert 2 &lt;= 2

assert 3 &lt;= 4


assert 5 &gt; 1

assert 5 &gt;= -2</code></pre>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_logical_operators">1.2.3. 逻辑运算符</h4>

<div class="paragraph">

<p>Groovy提供三个boolean值的逻辑运算符:</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>&amp;&amp;</code>: 逻辑 "并"</p>

</li>

<li>

<p><code>||</code>: 逻辑 "或"</p>

</li>

<li>

<p><code>!</code>: 逻辑 "非"</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>让我们举例说明他们的用法:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert !false           <i class="conum" data-value="1"></i><b>(1)</b>

assert true &amp;&amp; true     <i class="conum" data-value="2"></i><b>(2)</b>

assert true || false    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>"非"false即为true</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>true "并" true 仍为 true</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>true "或" false 为 true</td>

</tr>

</table>

</div>

<div class="sect4">

<h5 id="_precedence">优先级</h5>

<div class="paragraph">

<p>逻辑"非"比逻辑"并"的优先级更高.</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert !false &amp;&amp; true    <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>这里的结果为true，因为"非"比"并"拥有更高的优先级，否则，这个断言将会失败.</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>逻辑"并"比逻辑"或"拥有更高的优先级.</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert false || true &amp;&amp; true    <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>这里的结果为true，因为"并"比"或"拥有更高的优先级，否则，这个断言将会失败.</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_short_circuiting_for_code_code">短路的(<code>||</code>)</h5>

<div class="paragraph">

<p>逻辑运算符"或"支持短路：如果左边的操作数为true，那么就不会再验证右边的操作数。只有当左边的操作数为false时右边的操作数才会被验证.</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">called = false


boolean somethingTrueOrFalse(boolean b) {  <i class="conum" data-value="1"></i><b>(1)</b>

    called = true

    return b

}


assert true || somethingTrueOrFalse(false)

assert !called                              <i class="conum" data-value="2"></i><b>(2)</b>


assert false || somethingTrueOrFalse(true)

assert called                               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>我们创建一个方法返回boolean类型参数，方法内部设置了<code>called</code>的值.</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>在第一个案例中，刚刚的方法没有被调用，因为<code>||</code>的左边发生了短路.</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>在第二个案例中，方法被调用了，事实证明flag现在的值为true.</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_bitwise_operators">1.2.4. Bitwise operators</h4>

<div class="paragraph">

<p>Groovy offers 4 bitwise operators:</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>&amp;</code>: bitwise "and"</p>

</li>

<li>

<p><code>|</code>: bitwise "or"</p>

</li>

<li>

<p><code>^</code>: bitwise "xor" (exclusive "or")</p>

</li>

<li>

<p><code>~</code>: bitwise negation</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>Bitwise operators can be applied on a <code>byte</code> or an <code>int</code> and return an <code>int</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int a = 0b00101010

assert a==42

int b = 0b00001000

assert b==8

assert (a &amp; a) == a                     <i class="conum" data-value="1"></i><b>(1)</b>

assert (a &amp; b) == b                     <i class="conum" data-value="2"></i><b>(2)</b>

assert (a | a) == a                     <i class="conum" data-value="3"></i><b>(3)</b>

assert (a | b) == a                     <i class="conum" data-value="4"></i><b>(4)</b>


int mask = 0b11111111                   <i class="conum" data-value="5"></i><b>(5)</b>

assert ((a ^ a) &amp; mask) == 0b00000000   <i class="conum" data-value="6"></i><b>(6)</b>

assert ((a ^ b) &amp; mask) == 0b00100010   <i class="conum" data-value="7"></i><b>(7)</b>

assert ((~a) &amp; mask)    == 0b11010101   <i class="conum" data-value="8"></i><b>(8)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>bitwise and</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>bitwise and returns common bits</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>bitwise or</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>bitwise or returns all <em>1</em> bits</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>setting a mask to check only the last 8 bits</td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>bitwise exclusive or on self returns 0</td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>bitwise exclusive or</td>

</tr>

<tr>

<td><i class="conum" data-value="8"></i><b>8</b></td>

<td>bitwise negation</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>It&#8217;s worth noting that the internal representation of primitive types follow the <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html">Java Language Specification</a>. In particular,

primitive types are signed, meaning that for a bitwise negation, it is always good to use a mask to retrieve only the necessary bits.</p>

</div>

<div class="paragraph">

<p>In Groovy, bitwise operators have the particularity of being <a href="groovy_language_specification.html#Operator-Overloading">overloadable</a>, meaning that you can define the behavior of those operators for any kind of object.</p>

</div>

</div>

<div class="sect3">

<h4 id="_conditional_operators">1.2.5. Conditional operators</h4>

<div class="sect4">

<h5 id="_not_operator">Not operator</h5>

<div class="paragraph">

<p>The "not" operator is represented with an exclamation mark (<code>!</code>) and inverts the result of the underlying boolean expression. In

particular, it is possible to combine the <code>not</code> operator with the <a href="groovy_language_specification.html#Groovy-Truth">Groovy truth</a>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert (!true)    == false                      <i class="conum" data-value="1"></i><b>(1)</b>

assert (!'foo')   == false                      <i class="conum" data-value="2"></i><b>(2)</b>

assert (!'')      == true                       <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the negation of <code>true</code> is <code>false</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><em>foo</em> is a non empty string, evaluating to <code>true</code>, so negation returns <code>false</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>'' is an empty string, evaluating to <code>false</code>, so negation returns <code>true</code></td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_ternary_operator">Ternary operator</h5>

<div class="paragraph">

<p>The ternary operator is a shortcut expression that is equivalent to an if/else branch assigning some value to a variable.</p>

</div>

<div class="paragraph">

<p>Instead of:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">if (string!=null &amp;&amp; string.length()&gt;0) {

    result = 'Found'

} else {

    result = 'Not found'

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>You can write:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">result = (string!=null &amp;&amp; string.length()&gt;0)?'Found':'Not found'</code></pre>

</div>

</div>

<div class="paragraph">

<p>The ternary operator is also compatible with the <a href="groovy_language_specification.html#Groovy-Truth">Groovy truth</a>, so you can make it even simpler:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">result = string?'Found':'Not found'</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_elvis_operator">Elvis operator</h5>

<div class="paragraph">

<p>The "Elvis operator" is a shortening of the ternary operator. One instance of where this is handy is for returning

a <em>sensible default</em> value if an expression resolves to <code>false</code> or <code>null</code>. A simple example might look like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">displayName = user.name ? user.name : 'Anonymous'   <i class="conum" data-value="1"></i><b>(1)</b>

displayName = user.name ?: 'Anonymous'              <i class="conum" data-value="2"></i><b>(2)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>with the ternary operator, you have to repeat the value you want to assign</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>with the Elvis operator, the value which is tested is used if it is not <code>false</code> or <code>null</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Usage of the Elvis operator reduces the verbosity of your code and reduces the risks of errors in case of refactorings,

by removing the need to duplicate the expression which is tested in both the condition and the positive return value.</p>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_object_operators">1.2.6. Object operators</h4>

<div class="sect4">

<h5 id="_safe_navigation_operator">Safe navigation operator</h5>

<div class="paragraph">

<p>The Safe Navigation operator is used to avoid a <code>NullPointerException</code>. Typically when you have a reference to an object

you might need to verify that it is not <code>null</code> before accessing methods or properties of the object. To avoid this, the safe

navigation operator will simply return <code>null</code> instead of throwing an exception, like so:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def person = Person.find { it.id == 123 }           <i class="conum" data-value="1"></i><b>(1)</b>

def name = person?.name                             <i class="conum" data-value="2"></i><b>(2)</b>

assert name == null                                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>find</code> will return a <code>null</code> instance</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>use of the null-safe operator prevents from a <code>NullPointerException</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>result is <code>null</code></td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_direct_field_access_operator">Direct field access operator</h5>

<div class="paragraph">

<p>Normally in Groovy, when you write code like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class User {

    public final String name                               <i class="conum" data-value="1"></i><b>(1)</b>

    User(String name) { this.name = name}

    String getName() { "Name: $name" }                     <i class="conum" data-value="2"></i><b>(2)</b>

}

def user = new User('Bob')

assert user.name == 'Name: Bob'                            <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>public field <code>name</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>a getter for <code>name</code> that returns a custom string</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>calls the getter</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The <code>user.name</code> call triggers a call to the property of the same name, that is to say, here, to the getter for <code>name</code>. If

you want to retrieve the field instead of calling the getter, you can use the direct field access operator:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert user.@name == 'Bob'                                 <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>use of <code>.@</code> forces usage of the field instead of the getter</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_method_reference_operator">Method reference operator</h5>

<div class="paragraph">

<p>The method reference operator (<code>.&amp;</code>) call be used to store a reference to a method in a variable, in order to call it

later:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def str = 'example of method reference'            <i class="conum" data-value="1"></i><b>(1)</b>

def fun = str.&amp;toUpperCase                         <i class="conum" data-value="2"></i><b>(2)</b>

def upper = fun()                                  <i class="conum" data-value="3"></i><b>(3)</b>

assert upper == str.toUpperCase()                  <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>str</code> variable contains a <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we store a reference to the <code>toUpperCase</code> method on the <code>str</code> instance inside a variable named <code>fun</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>fun</code> can be called like a regular method</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>we can check that the result is the same as if we had called it directly on <code>str</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>There are multiple advantages in using method references. First of all, the type of such a method reference is

a <code>groovy.lang.Closure</code>, so it can be used in any place a closure would be used. In particular, it is suitable to

convert an existing method for the needs of the strategy pattern:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def transform(List elements, Closure action) {                                      <i class="conum" data-value="1"></i><b>(1)</b>

    def result = []

    elements.each {

        result &lt;&lt; action(it)

    }

    result

}

String describe(Person p) {                                                         <i class="conum" data-value="2"></i><b>(2)</b>

    "$p.name is $p.age"

}

def action = this.&amp;describe                                                         <i class="conum" data-value="3"></i><b>(3)</b>

def list = [new Person(name:'Bob', age:42), new Person(name:'Julia',age:35)]        <i class="conum" data-value="4"></i><b>(4)</b>

assert transform(list, action) == ['Bob is 42', 'Julia is 35']                      <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>transform</code> method takes each element of the list and calls the <code>action</code> closure on them, returning a new list</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we define a function that takes a <code>Person</code> a returns a <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>we create a method reference on that function</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>we create the list of elements we want to collect the descriptors</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>the method reference can be used where a <code>Closure</code> was expected</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Method references are bound by the receiver and a method name. Arguments are resolved at runtime, meaning that if you have

multiple methods with the same name, the syntax is not different, only resolution of the appropriate method to be called

will be done at runtime:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def doSomething(String str) { str.toUpperCase() }                                   <i class="conum" data-value="1"></i><b>(1)</b>

def doSomething(Integer x) { 2*x }                                                  <i class="conum" data-value="2"></i><b>(2)</b>

def reference = this.&amp;doSomething                                                   <i class="conum" data-value="3"></i><b>(3)</b>

assert reference('foo') == 'FOO'                                                    <i class="conum" data-value="4"></i><b>(4)</b>

assert reference(123)   == 246                                                      <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>define an overloaded <code>doSomething</code> method accepting a <code>String</code> as an argument</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>define an overloaded <code>doSomething</code> method accepting an <code>Integer</code> as an argument</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>create a single method reference on <code>doSomething</code>, without specifying argument types</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>using the method reference with a <code>String</code> calls the <code>String</code> version of <code>doSomething</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>using the method reference with an <code>Integer</code> calls the <code>Integer</code> version of <code>doSomething</code></td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_regular_expression_operators">1.2.7. Regular expression operators</h4>

<div class="sect4">

<h5 id="_pattern_operator">Pattern operator</h5>

<div class="paragraph">

<p>The pattern operator (<code>~</code>) provides a simple way to create a <code>java.util.regex.Pattern</code> instance:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def p = ~/foo/

assert p instanceof Pattern</code></pre>

</div>

</div>

<div class="paragraph">

<p>while in general, you find the pattern operator with an expression in a slashy-string, it can be used with any kind of

<code>String</code> in Groovy:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">p = ~'foo'                                                                              <i class="conum" data-value="1"></i><b>(1)</b>

p = ~'foo'                                                                              <i class="conum" data-value="2"></i><b>(2)</b>

p = ~$/dollar/slashy $ string/$                                                         <i class="conum" data-value="3"></i><b>(3)</b>

p = ~"${pattern}"                                                                       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>using single quote strings</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>using double quotes strings</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the dollar-slashy string lets you use slashes and the dollar sign without having to escape them</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>you can also use a GString!</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_find_operator">Find operator</h5>

<div class="paragraph">

<p>Alternatively to building a pattern, you can directly use the find operator <code>=~</code> to build a <code>java.util.regex.Matcher</code>

instance:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def text = "some text to match"

def m = text =~ /match/                                                                 <i class="conum" data-value="1"></i><b>(1)</b>

assert m instanceof Matcher                                                             <i class="conum" data-value="2"></i><b>(2)</b>

if (!m) {                                                                               <i class="conum" data-value="3"></i><b>(3)</b>

    throw new RuntimeException("Oops, text not found!")

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>~=</code> creates a matcher against the <code>text</code> variable, using the pattern on the right hand side</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the return type of <code>~=</code> is a <code>Matcher</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>equivalent to calling <code>if (!m.find())</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Since a <code>Matcher</code> coerces to a <code>boolean</code> by calling its <code>find</code> method, the <code>=~</code> operator is consistent with the simple

use of Perl&#8217;s <code>=~</code> operator, when it appears as a predicate (in <code>if</code>, <code>while</code>, etc.).</p>

</div>

</div>

<div class="sect4">

<h5 id="_match_operator">Match operator</h5>

<div class="paragraph">

<p>The match operator (<code>==~</code>) is a slight variation of the find operator, that does not return a <code>Matcher</code> but a boolean

and requires a strict match of the input string:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">m = text ==~ /match/                                                                    <i class="conum" data-value="1"></i><b>(1)</b>

assert m instanceof Boolean                                                             <i class="conum" data-value="2"></i><b>(2)</b>

if (m) {                                                                                <i class="conum" data-value="3"></i><b>(3)</b>

    throw new RuntimeException("Should not reach that point!")

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>~==</code> matches the subject with the regular expression, but match must be strict</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the return type of <code>~==</code> is therefore a <code>boolean</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>equivalent to calling <code>if (text ==~ /match/)</code></td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_other_operators_wip">1.2.8. Other operators (WIP)</h4>

<div class="sect4">

<h5 id="_spread_operator">Spread operator</h5>

<div class="paragraph">

<p>The Spread Operator (<code>*.</code>) is used to invoke an action on all items of an aggregate object. It is equivalent to calling the action on each item

and collecting the result into a list:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Car {

    String make

    String model

}

def cars = [

       new Car(make:'Peugeot', model:'508'),

       new Car(make:'Renault', model:'Clio')]                                    <i class="conum" data-value="1"></i><b>(1)</b>

def makes = cars*.make                                                           <i class="conum" data-value="2"></i><b>(2)</b>

assert makes == ['Peugeot', 'Renault']                                           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>build a list of <code>Car</code> items. The list is an aggregate of objects.</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>call the spread operator on the list, accessing the <code>make</code> property of each item</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>returns a list of strings corresponding to the collection of <code>make</code> items</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The spread operator is null-safe, meaning that if an element of the collection is null, it will return null instead of throwing a <code>NullPointerException</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">cars = [

   new Car(make:'Peugeot', model:'508'),

   null,                                                                         <i class="conum" data-value="1"></i><b>(1)</b>

   new Car(make:'Renault', model:'Clio')]

assert cars*.make == ['Peugeot', null, 'Renault']                                <i class="conum" data-value="2"></i><b>(2)</b>

assert null*.make == null                                                        <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>build a list for which of of the elements is <code>null</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>using the spread operator will <strong>not</strong> throw a <code>NullPointerException</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the receiver might also be null, in which case the return value is <code>null</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The spread operator can be used on any class which implements the <code>Iterable</code> interface:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Component {

    Long id

    String name

}

class CompositeObject implements Iterable&lt;Component&gt; {

    def components = [

        new Component(id:1, name: 'Foo'),

        new Component(id:2, name:'Bar')]


    @Override

    Iterator&lt;Component&gt; iterator() {

        components.iterator()

    }

}

def composite = new CompositeObject()

assert composite*.id == [1,2]

assert composite*.name == ['Foo','Bar']</code></pre>

</div>

</div>

<div class="sect5">

<h6 id="_spreading_method_arguments">Spreading method arguments</h6>

<div class="paragraph">

<p>There may be situations when the arguments of a method call can be found in a list that you need to adapt to the method

arguments. In such situations, you can use the spread operator to call the method. For example, imagine you have the

following method signature:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int function(int x, int y, int z) {

    x*y+z

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>then if you have the following list:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def args = [4,5,6]</code></pre>

</div>

</div>

<div class="paragraph">

<p>you can call the method without having to define intermediate variables:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert function(*args) == 26</code></pre>

</div>

</div>

<div class="paragraph">

<p>It is even possible to mix normal arguments with spread ones:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">args = [4]

assert function(*args,5,6) == 26</code></pre>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_spread_list_elements">Spread list elements</h6>

<div class="paragraph">

<p>When used inside a list literal, the spread operator acts as if the spread element contents were inlined into the list:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def items = [4,5]                      <i class="conum" data-value="1"></i><b>(1)</b>

def list = [1,2,3,*items,6]            <i class="conum" data-value="2"></i><b>(2)</b>

assert list == [1,2,3,4,5,6]           <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>items</code> is a list</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we want to insert the contents of the <code>items</code> list directly into <code>list</code> without having to call <code>addAll</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the contents of <code>items</code> has been inlined into <code>list</code></td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_spread_map_elements">Spread map elements</h6>

<div class="paragraph">

<p>The spread map operator works in a similar manner as the spread list operator, but for maps. It allows you to inline

the contents of a map into another map literal, like in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def m1 = [c: 3, d: 4]                 <i class="conum" data-value="1"></i><b>(1)</b>

def map = [a:1, b:2, *:m1]            <i class="conum" data-value="2"></i><b>(2)</b>

assert map == [a:1, b:2, c:3, d:4]    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>m1</code> is the map that we want to inline</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we use the <code>*:m1</code> notation to spread the contents of <code>m1</code> into <code>map</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>map</code> contains all the elements of <code>m1</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The position of the spread map operator is relevant, like illustrated in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def m1 = [c: 3, d: 4]                 <i class="conum" data-value="1"></i><b>(1)</b>

def map = [a:1, b:2, *:m1, d: 8]      <i class="conum" data-value="2"></i><b>(2)</b>

assert map == [a:1, b:2, c:3, d:8]    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>m1</code> is the map that we want to inline</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we use the <code>*:m1</code> notation to spread the contents of <code>m1</code> into <code>map</code>, but redefine the key <code>d</code> <strong>after</strong> spreading</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>map</code> contains all the expected keys, but <code>d</code> was redefined</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_range_operator">Range operator</h5>

<div class="paragraph">

<p>Groovy supports the concept of ranges and provides a notation (<code>..</code>) to create ranges of objects:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def range = 0..5                                    <i class="conum" data-value="1"></i><b>(1)</b>

assert (0..5).collect() == [0, 1, 2, 3, 4, 5]       <i class="conum" data-value="2"></i><b>(2)</b>

assert (0..&lt;5).collect() == [0, 1, 2, 3, 4]         <i class="conum" data-value="3"></i><b>(3)</b>

assert (0..5) instanceof List                       <i class="conum" data-value="4"></i><b>(4)</b>

assert (0..5).size() == 6                           <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>a simple range of integers, stored into a local variable</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>an <code>IntRange</code>, with inclusive bounds</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>an <code>IntRange</code>, with exclusive upper bound</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>a <code>groovy.lang.Range</code> implements the <code>List</code> interface</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>meaning that you can call the <code>size</code> method on it</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Ranges implementation is lightweight, meaning that only the lower and upper bounds are stored. You can create a range

from any <code>Comparable</code> object. For example, you can create a range of characters this way:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert ('a'..'d').collect() == ['a','b','c','d']</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_spaceship_operator">Spaceship operator</h5>

<div class="paragraph">

<p>The spaceship operator (<code>&lt;=&gt;</code>) delegates to the <code>compareTo</code> method:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert (1 &lt;=&gt; 1) == 0

assert (1 &lt;=&gt; 2) == -1

assert (2 &lt;=&gt; 1) == 1

assert ('a' &lt;=&gt; 'z') == -1</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="subscript-operator">Subscript operator</h5>

<div class="paragraph">

<p>The subscript operator is a short hand notation for <code>getAt</code> or <code>putAt</code>, depending on whether you find it on

the left hand side or the right hand side of an assignment:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def list = [0,1,2,3,4]

assert list[2] == 2                         <i class="conum" data-value="1"></i><b>(1)</b>

list[2] = 4                                 <i class="conum" data-value="2"></i><b>(2)</b>

assert list[0..2] == [0,1,4]                <i class="conum" data-value="3"></i><b>(3)</b>

list[0..2] = [6,6,6]                        <i class="conum" data-value="4"></i><b>(4)</b>

assert list == [6,6,6,3,4]                  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>[2]</code> can be used instead of <code>getAt(2)</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>if on left hand side of an assignment, will call <code>putAt</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>getAt</code> also supports ranges</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>so does <code>putAt</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>the list is mutated</td>

</tr>

</table>

</div>

<div id="custom-subscript-operator" class="paragraph">

<p>The subscript operator, in combination with a custom implementation of <code>getAt</code>/<code>putAt</code> is a convenient way for destructuring

objects:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class User {

    Long id

    String name

    def getAt(int i) {                                                  <i class="conum" data-value="1"></i><b>(1)</b>

        switch (i) {

            case 0: return id

            case 1: return name

        }

        throw new IllegalArgumentException("No such element $i")

    }

    void putAt(int i, def value) {                                      <i class="conum" data-value="2"></i><b>(2)</b>

        switch (i) {

            case 0: id = value; return

            case 1: name = value; return

        }

        throw new IllegalArgumentException("No such element $i")

    }

}

def user = new User(id: 1, name: 'Alex')                                <i class="conum" data-value="3"></i><b>(3)</b>

assert user[0] == 1                                                     <i class="conum" data-value="4"></i><b>(4)</b>

assert user[1] == 'Alex'                                                <i class="conum" data-value="5"></i><b>(5)</b>

user[1] = 'Bob'                                                         <i class="conum" data-value="6"></i><b>(6)</b>

assert user.name == 'Bob'                                               <i class="conum" data-value="7"></i><b>(7)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>User</code> class defines a custom <code>getAt</code> implementation</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the <code>User</code> class defines a custom <code>putAt</code> implementation</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>create a sample user</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>using the subscript operator with index 0 allows retrieving the user id</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>using the subscript operator with index 1 allows retrieving the user name</td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>we can use the subscript operator to write to a property thanks to the delegation to <code>putAt</code></td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>and check that it&#8217;s really the property <code>name</code> which was changed</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_membership_operator">Membership operator</h5>

<div class="paragraph">

<p>The membership operator (<code>in</code>) is equivalent to calling the <code>isCase</code> method. In the context of a <code>List</code>, it is equivalent

to calling <code>contains</code>, like in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def list = ['Grace','Rob','Emmy']

assert ('Emmy' in list)                     <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>equivalent to calling <code>list.contains('Emmy')</code> or <code>list.isCase('Emmy')</code></td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_identity_operator">Identity operator</h5>

<div class="paragraph">

<p>In Groovy, using <code>==</code> to test equality is different from using the same operator in Java. In Groovy, it is calling <code>equals</code>.

If you want to compare reference equality, you should use <code>is</code> like in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def list1 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        <i class="conum" data-value="1"></i><b>(1)</b>

def list2 = ['Groovy 1.8','Groovy 2.0','Groovy 2.3']        <i class="conum" data-value="2"></i><b>(2)</b>

assert list1 == list2                                       <i class="conum" data-value="3"></i><b>(3)</b>

assert !list1.is(list2)                                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>Create a list of strings</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>Create another list of strings containing the same elements</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>using <code>==</code>, we test object equality</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>but using <code>is</code>, we can check that references are distinct</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_coercion_operator">Coercion operator</h5>

<div class="paragraph">

<p>The coercion operator (<code>as</code>) is a variant of casting. Coercion converts object from one type to another <strong>without</strong> them

being compatible for assignement. Let&#8217;s take an example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Integer x = 123

String s = (String) x                                   <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>Integer</code> is not assignable to a <code>String</code>, so it will produce a <code>ClassCastException</code> at runtime</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>This can be fixed by using <em>coercion</em> instead:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Integer x = 123

String s = x as String                                  <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>Integer</code> is not assignable to a <code>String</code>, but use of <code>as</code> will <em>coerce</em> it to a <code>String</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>When an object is coerced into another, unless the target type is the same as the source type, coercion will return a

<strong>new</strong> object. The rules of coercion differ depending on the source and target types, and coercion may fail if no conversion

rules are found. Custom conversion rules may be implemented thanks to the <code>asType</code> method:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Identifiable {

    String name

}

class User {

    Long id

    String name

    def asType(Class target) {                                              <i class="conum" data-value="1"></i><b>(1)</b>

        if (target==Identifiable) {

            return new Identifiable(name: name)

        }

        throw new ClassCastException("User cannot be coerced into $target")

    }

}

def u = new User(name: 'Xavier')                                            <i class="conum" data-value="2"></i><b>(2)</b>

def p = u as Identifiable                                                   <i class="conum" data-value="3"></i><b>(3)</b>

assert p instanceof Identifiable                                            <i class="conum" data-value="4"></i><b>(4)</b>

assert !(p instanceof User)                                                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>User</code> class defines a custom conversion rule from <code>User</code> to <code>Identifiable</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we create an instance of <code>User</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>we coerce the <code>User</code> instance into an <code>Identifiable</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>the target is an instance of <code>Identifiable</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>the target is not an instance of <code>User</code> anymore</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_diamond_operator">Diamond operator</h5>

<div class="paragraph">

<p>The diamond operator (<code>&lt;&gt;</code>) is a syntactic sugar only operator added to support compatibility with the operator of the

same name in Java 7. It is used to indicate that generic types should be inferred from the declaration:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">List&lt;String&gt; strings = new LinkedList&lt;&gt;()</code></pre>

</div>

</div>

<div class="paragraph">

<p>In dynamic Groovy, this is totally unused. In statically type checked Groovy, it is also optional since the Groovy

type checker performs type inference whether this operator is present or not.</p>

</div>

</div>

<div class="sect4">

<h5 id="_call_operator">Call operator</h5>

<div class="paragraph">

<p>The call operator <code>()</code> is used to call a method named <code>call</code> implicitly. For any object which defines a <code>call</code> method,

 you can omit the <code>.call</code> part and use the call operator instead:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class MyCallable {

    int call(int x) {           <i class="conum" data-value="1"></i><b>(1)</b>

        2*x

    }

}


def mc = new MyCallable()

assert mc.call(2) == 4          <i class="conum" data-value="2"></i><b>(2)</b>

assert mc(2) == 4               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>MyCallable</code> defines a method named <code>call</code>. Note that it doesn&#8217;t need to implement <code>java.util.concurrent.Callable</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we can call the method using the classic method call syntax</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>or we can omit <code>.call</code> thanks to the call operator</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_operator_precedence_tbd">1.2.9. Operator precedence (TBD)</h4>


</div>

<div class="sect3">

<h4 id="Operator-Overloading">1.2.10. Operator overloading</h4>

<div class="paragraph">

<p>Groovy allows you to overload the various operators so that they can be used with your own classes. Consider this simple

class:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Bucket {

    int size


    Bucket(int size) { this.size = size }


    Bucket plus(Bucket other) {                     <i class="conum" data-value="1"></i><b>(1)</b>

        return new Bucket(this.size + other.size)

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>Bucket</code> implements a special method called <code>plus()</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Just by implementing the <code>plus()</code> method, the <code>Bucket</code> class can now be used with the <code>+</code> operator like so:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def b1 = new Bucket(4)

def b2 = new Bucket(11)

assert (b1 + b2).size == 15                         <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>The two <code>Bucket</code> objects can be added together with the <code>+</code> operator</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>All (non-comparator) Groovy operators have a corresponding method that you can implement in your own classes. The only

requirements are that your method is public, has the correct name, and has the correct number of arguments. The argument

types depend on what types you want to support on the right hand side of the operator. For example, you could support

the statement</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert (b1 + 11).size == 15</code></pre>

</div>

</div>

<div class="paragraph">

<p>by implementing the <code>plus()</code> method with this signature:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Bucket plus(int capacity) {

    return new Bucket(this.size + capacity)

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Here is a complete list of the operators and their corresponding methods:</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 25%;">

<col style="width: 25%;">

<col style="width: 25%;">

<col style="width: 25%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">Operator</th>

<th class="tableblock halign-left valign-top">Method</th>

<th class="tableblock halign-left valign-top">Operator</th>

<th class="tableblock halign-left valign-top">Method</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.plus(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b]</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.getAt(b)</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.minus(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>a[b] = c</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.putAt(b, c)</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>*</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.multiply(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&lt;&lt;</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.leftShift(b)</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.div(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&gt;&gt;</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.rightShift(b)</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>%</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.mod(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>++</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.next()</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>**</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.power(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.previous()</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>|</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.or(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>+a</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.positive()</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>&amp;</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.and(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-a</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.negative()</p></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>^</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.xor(b)</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock"><code>~a</code></p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">a.bitwiseNegative()</p></td>

</tr>

</tbody>

</table>

</div>

</div>

<div class="sect2">

<h3 id="_program_structure_anto_aravinth">1.3. Program structure (Anto Aravinth)</h3>

<div class="paragraph">

<p>This chapter covers the program structure of the Groovy programming language.</p>

</div>

<div class="sect3">

<h4 id="_package_name_tbd">1.3.1. Package name (TBD)</h4>


</div>

<div class="sect3">

<h4 id="_imports_tbd">1.3.2. Imports (TBD)</h4>

<div class="sect4">

<h5 id="_default_imports_tbd">Default imports (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_simple_import_tbd">Simple import (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_star_import_tbd">Star import (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_static_import_tbd">Static import (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_static_star_import_tbd">Static star import (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_import_aliasing_tbd">Import aliasing (TBD)</h5>


</div>

</div>

<div class="sect3">

<h4 id="_scripts_versus_classes">1.3.3. Scripts versus classes</h4>

<div class="paragraph">

<p>Package name plays exactly the same role as they used to play in Java. They allows us to separate the code base without any conflicts. Groovy classes must specify their package before the class definition, else the default package is assumed.</p>

</div>

<div class="paragraph">

<p>Defining a package is very similar to java, as you can see</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">//Defines a package named com.yoursite

package com.yoursite</code></pre>

</div>

</div>

<div class="paragraph">

<p>To refer the class <code>Foo</code> in the <code>com.yoursite.com</code> package then you need to use <code>com.yoursite.com.Foo</code> in your code else you can use <code>import</code> statement as we can see now.</p>

</div>

</div>

<div class="sect3">

<h4 id="_imports">1.3.4. Imports</h4>

<div class="paragraph">

<p>In order to refer any class you need a reference for it. Groovy follows Java&#8217;s notion of allowing <code>import</code> statement to resolve the class references. Groovy provides several builder classes,

one such class is <code>MarkupBuilder</code>. <code>MarkupBuilder</code> is inside the package <code>groovy.xml</code>, in order to use this class, you need to <code>import</code> it as shown:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">//imports the class MarkupBuilder

import groovy.xml.MarkupBuilder


//uses the imported class to create an object

def xml = new MarkupBuilder( )


assert xml != null</code></pre>

</div>

</div>

<div class="sect4">

<h5 id="_default_imports">Default imports</h5>

<div class="paragraph">

<p>Default imports are the imports that Groovy language provides by default. For example look at the following code:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">new Date()</code></pre>

</div>

</div>

<div class="paragraph">

<p>The same code in Java needs an import statement to <code>Date</code> class like this: <code>import java.util.Date</code>. Groovy by default imports these classes for you. There are six packages that groovy imports for you, they are:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import java.lang.*

import java.util.*

import java.io.*

import java.net.*

import groovy.lang.*

import groovy.util.*

import java.math.BigInteger

import java.math.BigDecimal</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_simple_import">Simple import</h5>

<div class="paragraph">

<p>Simple import is an import, where you fully define the class name along with the package. For example the import statement <code>import groovy.xml.MarkupBuilder</code> in the code below is the simple import, which directly refer the class inside the package.</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">//imports the class MarkupBuilder

import groovy.xml.MarkupBuilder


//uses the imported class to create an object

def xml = new MarkupBuilder( )


assert xml != null</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_star_import">Star import</h5>

<div class="paragraph">

<p>Groovy (like Java) provides a special way to import all classes from a package using <code>*</code>, they are called as Star import. <code>MarkupBuilder</code> is class which is in package <code>groovy.xml</code>, another class called <code>StreamingMarkupBuilder</code> is in the same package. Consider the case, where you need to use two classes, then you can do:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.xml.MarkupBuilder

import groovy.xml.StreamingMarkupBuilder


def markupBuilder = new MarkupBuilder( )


assert markupBuilder != null


assert new StreamingMarkupBuilder() != null</code></pre>

</div>

</div>

<div class="paragraph">

<p>Thats a perfectly valid code. But with <code>*</code> import, we can do the same like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.xml.*


def markupBuilder = new MarkupBuilder( )


assert markupBuilder != null


assert new StreamingMarkupBuilder() != null</code></pre>

</div>

</div>

<div class="paragraph">

<p>where, <code><strong></code> does imports all the class under package <code>groovy.xml</code>. Using <code></strong></code> import can clutters your local namespace. But with groovy type aliasing, this can be solved easily.</p>

</div>

</div>

<div class="sect4">

<h5 id="_static_import">Static import</h5>

<div class="paragraph">

<p>Groovy&#8217;s static import capability allows you to reference imported classes as if they were static methods in your own class. This is similar to Java&#8217;s static import capability but works with Java 1.4 and above and is a little more dynamic than Java in that it allows you to define methods with the same name as an imported method as long as you have different types. If you have the same types, the imported class takes precedence. Here is a sample of its usage:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import static Boolean.FALSE


assert !FALSE //use directly, without Boolean prefix!</code></pre>

</div>

</div>

<div class="paragraph">

<p>As you can see, now we can able to refer the static variable <code>FALSE</code> in our code base cleanly.</p>

</div>

<div class="paragraph">

<p>Static imports along with <code>as</code> keyword can make elegant solution. Consider you want to get the <code>Calendar</code> instance, using <code>getInstance()</code> method. Its a static method, so we can do a static import. But instead of calling <code>getInstance()</code> everytime, we can do this which can increase code readability:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import static Calendar.getInstance as now


assert now().class == Calendar.getInstance().class</code></pre>

</div>

</div>

<div class="paragraph">

<p>Thats clean and sweet!</p>

</div>

</div>

<div class="sect4">

<h5 id="_static_star_import">Static star import</h5>

<div class="paragraph">

<p>Its very similar to the star import that we have seen earlier. It will import all the static methods from the given class. For example, lets say we need to calculate sin and cos for our application.

The class <code>java.lang.Math</code> has static methods named <code>sin</code>,<code>cos</code> which fits our need. With help of static star import, we can do:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import static java.lang.Math.*


assert sin(0) == 0.0

assert cos(0) == 1.0</code></pre>

</div>

</div>

<div class="paragraph">

<p>As you can see, we were able to access the methods <code>sin</code>,<code>cos</code> directly, instead like <code>Math.sin</code>.</p>

</div>

</div>

<div class="sect4">

<h5 id="_import_aliasing">Import aliasing</h5>

<div class="paragraph">

<p>With type aliasing, we can refer to a fully qualified class name with the name of your choice. This can be done with <code>as</code> keyword in Groovy.</p>

</div>

<div class="paragraph">

<p>Consider the class with the following library code:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">package thirdpartylib


public class MultiplyTwo {

    def static multiply(def value) {

        return value * 3 //intentionally wrong.

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>and we have some existing code using this library:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def result = new MultiplyTwo().multiply(2)</code></pre>

</div>

</div>

<div class="paragraph">

<p>Obviously, the <code>result</code> variable contains the wrong result. And assume you have used this library through out your code-base. Groovy has an elegant way to fix this issue.</p>

</div>

<div class="paragraph">

<p>With the type aliasing in place, we can fix the bug using the below code:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import thirdpartylib.MultiplyTwo as OrigMultiplyTwo

class MultiplyTwo extends OrigMultiplyTwo {

    def multiply(def value)

    {

        return value * 2 //corrected here

    }

}

// nothing changes below here

def multiplylib = new MultiplyTwo()


//assert passes as well

assert 4 == new MultiplyTwo().multiply(2)</code></pre>

</div>

</div>

<div class="paragraph">

<p>Thats it! Notice how Groovy allowed us to use <code>as</code> keyword to solve the typical problem.</p>

</div>

<div class="paragraph">

<p>With Type aliasing we can able to solve the name collision problem ( which can occur with <code>*</code> imports) elegantly.</p>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_initializers_tbd">1.3.5. Initializers (TBD)</h4>

<div class="sect4">

<h5 id="_static_initializers_tbd">Static initializers (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_instance_initializers_tbd">Instance initializers (TBD)</h5>


</div>

</div>

</div>

<div class="sect2">

<h3 id="_object_orientation">1.4. Object orientation</h3>

<div class="paragraph">

<p>This chapter covers the object orientation of the Groovy programming language.</p>

</div>

<div class="sect3">

<h4 id="_types_tbd">1.4.1. Types (TBD)</h4>

<div class="sect4">

<h5 id="_primitive_types_tbd">Primitive types (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_class_tbd">Class (TBD)</h5>

<div class="sect5">

<h6 id="_normal_class_tbd">Normal class (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_static_class_tbd">Static class (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_inner_class_tbd">Inner class (TBD)</h6>

<div class="sect6">

<h7 id="_anonymous_inner_class_tbd">Anonymous inner class (TBD)</h7>


</div>

</div>

<div class="sect5">

<h6 id="_abstract_class_tbd">Abstract class (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_interface_tbd">Interface (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_annotation_tbd">Annotation (TBD)</h5>

<div class="sect5">

<h6 id="_closure_annotation_parameters_tbd">Closure annotation parameters (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_meta_annotations_tbd">Meta-annotations (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_annotation_placement_tbd">Annotation placement (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_constructors_tbd">Constructors (TBD)</h5>

<div class="sect5">

<h6 id="_named_argument_constructor_tbd">Named argument constructor (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_methods_tbd">Methods (TBD)</h5>

<div class="sect5">

<h6 id="_method_definition_tbd">Method definition (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_named_arguments_tbd">Named arguments (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_default_arguments_tbd">Default arguments (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_varargs_tbd">Varargs (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_method_selection_algorithm_tbd">Method selection algorithm (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_exception_declaration_tbd">Exception declaration (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_fields_and_properties_tbd">Fields and properties (TBD)</h5>

<div class="sect5">

<h6 id="_fields_tbd">Fields (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_properties_tbd">Properties (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_inheritance_tbd">Inheritance (TBD)</h5>


</div>

<div class="sect4">

<h5 id="generics">Generics (TBD)</h5>


</div>

</div>

<div class="sect3">

<h4 id="_traits">1.4.2. Traits</h4>

<div class="paragraph">

<p>Traits are a a structural construct of the language which allow:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>composition of behaviors</p>

</li>

<li>

<p>runtime implementation of interfaces</p>

</li>

<li>

<p>behavior overriding</p>

</li>

<li>

<p>compatibility with static type checking/compilation</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>They can be seen as <strong>interfaces</strong> carrying both <strong>default implementations</strong> and <strong>state</strong>. A trait is defined using the

<code>trait</code> keyword:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>

        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>declaration of a trait</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>declaration of a method inside a trait</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Then it can be used like a normal interface using the <code>implements</code> keyword:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Bird implements FlyingAbility {}          <i class="conum" data-value="1"></i><b>(1)</b>

def b = new Bird()                              <i class="conum" data-value="2"></i><b>(2)</b>

assert b.fly() == "I'm flying!"                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>Adds the trait <code>FlyingAbility</code> to the <code>Bird</code> class capabilities</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>instantiate a new <code>Bird</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the <code>Bird</code> class automatically gets the behavior of the <code>FlyingAbility</code> trait</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Traits allow a wide range of capabilities, from simple composition to testing, which are described throughfully in this section.</p>

</div>

<div class="sect4">

<h5 id="_methods">Methods</h5>

<div class="sect5">

<h6 id="_public_methods">Public methods</h6>

<div class="paragraph">

<p>Declaring a method in a trait can be done like any regular method in a class:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>

        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>declaration of a trait</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>declaration of a method inside a trait</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_abstract_methods">Abstract methods</h6>

<div class="paragraph">

<p>In addition, traits may declare <em>abstract</em> methods too, which therefore need to be implemented in the class implementing the trait:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Greetable {

    abstract String name()                              <i class="conum" data-value="1"></i><b>(1)</b>

    String greeting() { "Hello, ${name()}!" }           <i class="conum" data-value="2"></i><b>(2)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>implementing class will have to declare the <code>name</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>can be mixed with a concrete method</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Then the trait can be used like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Person implements Greetable {                     <i class="conum" data-value="1"></i><b>(1)</b>

    String name() { 'Bob' }                             <i class="conum" data-value="2"></i><b>(2)</b>

}


def p = new Person()

assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>implement the trait <code>Greetable</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>since <code>name</code> was abstract, it is required to implement it</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>then <code>greeting</code> can be called</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_private_methods">Private methods</h6>

<div class="paragraph">

<p>Traits may also define private methods. Those methods will not appear in the trait contract interface:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Greeter {

    private String greetingMessage() {                      <i class="conum" data-value="1"></i><b>(1)</b>

        'Hello from a private method!'

    }

    String greet() {

        def m = greetingMessage()                           <i class="conum" data-value="2"></i><b>(2)</b>

        println m

        m

    }

}

class GreetingMachine implements Greeter {}                 <i class="conum" data-value="3"></i><b>(3)</b>

def g = new GreetingMachine()

assert g.greet() == "Hello from a private method!"          <i class="conum" data-value="4"></i><b>(4)</b>

try {

    assert g.greetingMessage()                              <i class="conum" data-value="5"></i><b>(5)</b>

} catch (MissingMethodException e) {

    println "greetingMessage is private in trait"

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>define a private method <code>greetingMessage</code> in the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the public <code>greet</code> message calls <code>greetingMessage</code> by default</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>create a class implementing the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td><code>greet</code> can be called</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>but not <code>greetingMessage</code></td>

</tr>

</table>

</div>

<div class="admonitionblock warning">

<table>

<tr>

<td class="icon">

<i class="icon-warning" title="Warning"></i>

</td>

<td class="content">

Traits only support <code>public</code> and <code>private</code> methods. Neither <code>protected</code> nor <code>package private</code> scopes are

supported.

</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_the_meaning_of_this">The meaning of this</h5>

<div class="paragraph">

<p><code>this</code> represents the implementing instance. Think of a trait as a superclass. This means that when you write:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Introspector {

    def whoAmI() { this }

}

class Foo implements Introspector {}

def foo = new Foo()</code></pre>

</div>

</div>

<div class="paragraph">

<p>then calling:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">foo.whoAmI()</code></pre>

</div>

</div>

<div class="paragraph">

<p>will return the same instance:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert foo.whoAmI().is(foo)</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_interfaces">Interfaces</h5>

<div class="paragraph">

<p>Traits may implement interfaces, in which case the interfaces are declared using the <code>implements</code> keyword:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface Named {                                       <i class="conum" data-value="1"></i><b>(1)</b>

    String name()

}

trait Greetable implements Named {                      <i class="conum" data-value="2"></i><b>(2)</b>

    String greeting() { "Hello, ${name()}!" }

}

class Person implements Greetable {                     <i class="conum" data-value="3"></i><b>(3)</b>

    String name() { 'Bob' }                             <i class="conum" data-value="4"></i><b>(4)</b>

}


def p = new Person()

assert p.greeting() == 'Hello, Bob!'                    <i class="conum" data-value="5"></i><b>(5)</b>

assert p instanceof Named                               <i class="conum" data-value="6"></i><b>(6)</b>

assert p instanceof Greetable                           <i class="conum" data-value="7"></i><b>(7)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>declaration of a normal interface</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>add <code>Named</code> to the list of implemented interfaces</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>declare a class that implements the <code>Greetable</code> trait</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>implement the missing <code>greet</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>the <code>greeting</code> implementation comes from the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>make sure <code>Person</code> implements the <code>Named</code> interface</td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>make sure <code>Person</code> implements the <code>Greetable</code> trait</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_properties">Properties</h5>

<div class="paragraph">

<p>A trait may define properties, like in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Named {

    String name                             <i class="conum" data-value="1"></i><b>(1)</b>

}

class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>

def p = new Person(name: 'Bob')             <i class="conum" data-value="3"></i><b>(3)</b>

assert p.name == 'Bob'                      <i class="conum" data-value="4"></i><b>(4)</b>

assert p.getName() == 'Bob'                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>declare a property <code>name</code> inside a trait</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>declare a class which implements the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the property is automatically made visible</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>it can be accessed using the regular property accessor</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>or using the regular getter syntax</td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_fields">Fields</h5>

<div class="sect5">

<h6 id="_private_fields">Private fields</h6>

<div class="paragraph">

<p>Since traits allow the use of private methods, it can also be interesting to use private fields to store state. Traits

will let you do that:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Counter {

    private int count = 0                   <i class="conum" data-value="1"></i><b>(1)</b>

    int count() { count += 1; count }       <i class="conum" data-value="2"></i><b>(2)</b>

}

class Foo implements Counter {}             <i class="conum" data-value="3"></i><b>(3)</b>

def f = new Foo()

assert f.count() == 1                       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="admonitionblock tip">

<table>

<tr>

<td class="icon">

<i class="icon-tip" title="Tip"></i>

</td>

<td class="content">

This is a major difference with <a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html">Java 8 virtual extension methods</a>. While virtual extension methods

do not carry state, traits can. Also interesting traits in Groovy are supported starting with Java 6, but their implementation do not rely on virtual extension methods. This

means that even if a trait can be seen from a Java class as a regular interface, this interface will <strong>not</strong> have default methods, only abstract ones.

</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_public_fields">Public fields</h6>

<div class="paragraph">

<p>Public fields work the same way as private fields, but in order to avoid the <a href="http://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem">diamond problem</a>,

field names are remapped in the implementing class:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Named {

    public String name                      <i class="conum" data-value="1"></i><b>(1)</b>

}

class Person implements Named {}            <i class="conum" data-value="2"></i><b>(2)</b>

def p = new Person()                        <i class="conum" data-value="3"></i><b>(3)</b>

p.Named__name = 'Bob'                       <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>declare a public <strong>field</strong> inside the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>declare a class implementing the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>create an instance of that class</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>the public field is available, but renamed</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The name of the field depends on the fully qualified name of the trait. All dots (<code>.</code>) in package are replaced with an underscore (<code>_</code>), and the final name includes a double underscore.

So if the type of the field is <code>String</code>, the name of the package is <code>my.package</code>, the name of the trait is <code>Foo</code> and the name of the field is <code>bar</code>,

in the implementing class, the public field will appear as:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String my_package_Foo__bar</code></pre>

</div>

</div>

<div class="admonitionblock warning">

<table>

<tr>

<td class="icon">

<i class="icon-warning" title="Warning"></i>

</td>

<td class="content">

While traits support public fields, it is not recommanded to use them and considered as a bad practice.

</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_composition_of_behaviors">Composition of behaviors</h5>

<div class="paragraph">

<p>Traits can be used to implement multiple inheritance in a controlled way, avoiding the diamond issue. For example, we

can have the following traits:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait FlyingAbility {                           <i class="conum" data-value="1"></i><b>(1)</b>

        String fly() { "I'm flying!" }          <i class="conum" data-value="2"></i><b>(2)</b>

}

trait SpeakingAbility {

    String speak() { "I'm speaking!" }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>And a class implementing both traits:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Duck implements FlyingAbility, SpeakingAbility {} <i class="conum" data-value="1"></i><b>(1)</b>


def d = new Duck()                                      <i class="conum" data-value="2"></i><b>(2)</b>

assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>

assert d.speak() == "I'm speaking!"                     <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>Duck</code> class implements both <code>FlyingAbility</code> and <code>SpeakingAbility</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>creates a new instance of <code>Duck</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>we can call the method <code>fly</code> from <code>FlyingAbility</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>but also the method <code>speak</code> from <code>SpeakingAbility</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Traits encourage the reuse of capabilities among objects, and the creation of new classes by the composition of existing behavior.</p>

</div>

</div>

<div class="sect4">

<h5 id="_overriding_default_methods">Overriding default methods</h5>

<div class="paragraph">

<p>Traits provide default implementations for methods, but it is possible to override them in the implementing class. For example, we

can slightly change the example above, by having a duck which quacks:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Duck implements FlyingAbility, SpeakingAbility {

    String quack() { "Quack!" }                         <i class="conum" data-value="1"></i><b>(1)</b>

    String speak() { quack() }                          <i class="conum" data-value="2"></i><b>(2)</b>

}


def d = new Duck()

assert d.fly() == "I'm flying!"                         <i class="conum" data-value="3"></i><b>(3)</b>

assert d.quack() == "Quack!"                            <i class="conum" data-value="4"></i><b>(4)</b>

assert d.speak() == "Quack!"                            <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>define a method specific to <code>Duck</code>, named <code>quack</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>override the default implementation of <code>speak</code> so that we use <code>quack</code> instead</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the duck is still flying, from the default implementation</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td><code>quack</code> comes from the <code>Duck</code> class</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td><code>speak</code> no longer uses the default implementation from <code>SpeakingAbility</code></td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_extending_traits">Extending traits</h5>

<div class="sect5">

<h6 id="_simple_inheritance">Simple inheritance</h6>

<div class="paragraph">

<p>Traits may extend another trait, in which case you must use the <code>extends</code> keyword:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Named {

    String name                                     <i class="conum" data-value="1"></i><b>(1)</b>

}

trait Polite extends Named {                        <i class="conum" data-value="2"></i><b>(2)</b>

    String introduce() { "Hello, I am $name" }      <i class="conum" data-value="3"></i><b>(3)</b>

}

class Person implements Polite {}

def p = new Person(name: 'Alice')                   <i class="conum" data-value="4"></i><b>(4)</b>

assert p.introduce() == 'Hello, I am Alice'         <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>Named</code> trait defines a single <code>name</code> property</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the <code>Polite</code> trait <strong>extends</strong> the <code>Named</code> trait</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>Polite</code> adds a new method which has access to the <code>name</code> property of the super-trait</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>the <code>name</code> property is visible from the <code>Person</code> class implementing <code>Polite</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>as is the <code>introduce</code> method</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_multiple_inheritance">Multiple inheritance</h6>

<div class="paragraph">

<p>Alternatively, a trait may extend multiple traits. In that case, all super traits must be declared in the <code>implements</code>

clause:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait WithId {                                      <i class="conum" data-value="1"></i><b>(1)</b>

    Long id

}

trait WithName {                                    <i class="conum" data-value="2"></i><b>(2)</b>

    String name

}

trait Identified implements WithId, WithName {}     <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>WithId</code> trait defines the <code>id</code> property</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><code>WithName</code> trait defines the <code>name</code> property</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>Identified</code> is a trait which inherits both <code>WithId</code> and <code>WithName</code></td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_duck_typing_and_traits">Duck typing and traits</h5>

<div class="sect5">

<h6 id="_dynamic_code">Dynamic code</h6>

<div class="paragraph">

<p>Traits can call any dynamic code, like a normal Groovy class. This means that you can, in the body of a method, call

methods which are supposed to exist in an implementing class, without having to explicitly declare them in an interface.

This means that traits are fully compatible with duck typing:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait SpeakingDuck {

    String speak() { quack() }                      <i class="conum" data-value="1"></i><b>(1)</b>

}

class Duck implements SpeakingDuck {

    String methodMissing(String name, args) {

        "${name.capitalize()}!"                     <i class="conum" data-value="2"></i><b>(2)</b>

    }

}

def d = new Duck()

assert d.speak() == 'Quack!'                        <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>SpeakingDuck</code> expects the <code>quack</code> method to be defined</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the <code>Duck</code> class does implement the method using <em>methodMissing</em></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>calling the <code>speak</code> method triggers a call to <code>quack</code> which is handled by <code>methodMissing</code></td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_dynamic_methods_in_a_trait">Dynamic methods in a trait</h6>

<div class="paragraph">

<p>It is also possible for a trait to implement MOP methods like <code>methodMissing</code> or <code>propertyMissing</code>, in which case implementing classes

will inherit the behavior from the trait, like in this example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait DynamicObject {                               <i class="conum" data-value="1"></i><b>(1)</b>

    private Map props = [:]

    def methodMissing(String name, args) {

        name.toUpperCase()

    }

    def propertyMissing(String prop) {

        props['prop']

    }

    void setProperty(String prop, Object value) {

        props['prop'] = value

    }

}


class Dynamic implements DynamicObject {

    String existingProperty = 'ok'                  <i class="conum" data-value="2"></i><b>(2)</b>

    String existingMethod() { 'ok' }                <i class="conum" data-value="3"></i><b>(3)</b>

}

def d = new Dynamic()

assert d.existingProperty == 'ok'                   <i class="conum" data-value="4"></i><b>(4)</b>

assert d.foo == null                                <i class="conum" data-value="5"></i><b>(5)</b>

d.foo = 'bar'                                       <i class="conum" data-value="6"></i><b>(6)</b>

assert d.foo == 'bar'                               <i class="conum" data-value="7"></i><b>(7)</b>

assert d.existingMethod() == 'ok'                   <i class="conum" data-value="8"></i><b>(8)</b>

assert d.someMethod() == 'SOMEMETHOD'               <i class="conum" data-value="9"></i><b>(9)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>create a trait implementing several MOP methods</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the <code>Dynamic</code> class defines a property</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the <code>Dynamic</code> class defines a method</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>calling an existing property will call the method from <code>Dynamic</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>calling an non-existing property will call the method from the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>will call <code>setProperty</code> defined on the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>will call <code>getProperty</code> defined on the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="8"></i><b>8</b></td>

<td>calling an existing method on <code>Dynamic</code></td>

</tr>

<tr>

<td><i class="conum" data-value="9"></i><b>9</b></td>

<td>but calling a non existing method thanks to the trait <code>methodMissing</code></td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_multiple_inheritance_conflicts">Multiple inheritance conflicts</h5>

<div class="sect5">

<h6 id="_default_conflict_resolution">Default conflict resolution</h6>

<div class="paragraph">

<p>It is possible for a class to implement multiple traits. If some trait defines a method with the same signature as a

method in another trait, we have a conflict:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait A {

    String exec() { 'A' }               <i class="conum" data-value="1"></i><b>(1)</b>

}

trait B {

    String exec() { 'B' }               <i class="conum" data-value="2"></i><b>(2)</b>

}

class C implements A,B {}               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>trait <code>A</code> defines a method named <code>exec</code> returning a <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>trait <code>B</code> defines the very same method</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>class <code>C</code> implements both traits</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>In this case, the default behavior is that methods from the <strong>last declared trait</strong> wins. Here, <code>B</code> is declared after <code>A</code>

so the method from <code>B</code> will be picked up:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def c = new C()

assert c.exec() == 'B'</code></pre>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_user_conflict_resolution">User conflict resolution</h6>

<div class="paragraph">

<p>In case this behavior is not the one you want, you can explicitly choose which method to call using the <code>Trait.super.foo</code> syntax.

In the example above, we can force to choose the method from trait A, by writing this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class C implements A,B {

    String exec() { A.super.exec() }    <i class="conum" data-value="1"></i><b>(1)</b>

}

def c = new C()

assert c.exec() == 'A'                  <i class="conum" data-value="2"></i><b>(2)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>explicit call of <code>exec</code> from the trait <code>A</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>calls the version from <code>A</code> instead of using the default resolution, which would be the one from <code>B</code></td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_runtime_implementation_of_traits">Runtime implementation of traits</h5>

<div class="sect5">

<h6 id="_implementing_a_trait_at_runtime">Implementing a trait at runtime</h6>

<div class="paragraph">

<p>Groovy also supports implementing traits dynamically at runtime. It allows you to "decorate" an existing object using a

trait. As an example, let&#8217;s start with this trait and the following class:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Extra {

    String extra() { "I'm an extra method" }            <i class="conum" data-value="1"></i><b>(1)</b>

}

class Something {                                       <i class="conum" data-value="2"></i><b>(2)</b>

    String doSomething() { 'Something' }                <i class="conum" data-value="3"></i><b>(3)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>Extra</code> trait defines an <code>extra</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the <code>Something</code> class does <strong>not</strong> implement the <code>Extra</code> trait</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>Something</code> only defines a method <code>doSomething</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Then if we do:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def s = new Something()

s.extra()</code></pre>

</div>

</div>

<div class="paragraph">

<p>the call to extra would fail because <code>Something</code> is not implementing <code>Extra</code>. It is possible to do it at runtime with

the following syntax:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def s = new Something() as Extra                        <i class="conum" data-value="1"></i><b>(1)</b>

s.extra()                                               <i class="conum" data-value="2"></i><b>(2)</b>

s.doSomething()                                         <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>use of the <strong>as</strong> keyword to coerce an object to a trait <strong>at runtime</strong></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>then <code>extra</code> can be called on the object</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>and <code>doSomething</code> is still callable</td>

</tr>

</table>

</div>

<div class="admonitionblock important">

<table>

<tr>

<td class="icon">

<i class="icon-important" title="Important"></i>

</td>

<td class="content">

When coercing an object to a trait, the result of the operation is not the same instance. It is guaranteed

that the coerced object will implement both the trait <strong>and</strong> the interfaces that the original object implements, but

the result will <strong>not</strong> be an instance of the original class.

</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_implementing_multiple_traits_at_once">Implementing multiple traits at once</h6>

<div class="paragraph">

<p>Should you need to implement several traits at once, you can use the <code>withTraits</code> method instead of the <code>as</code> keyword:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait A { void methodFromA() {} }

trait B { void methodFromB() {} }


class C {}


def c = new C()

c.methodFromA()                     <i class="conum" data-value="1"></i><b>(1)</b>

c.methodFromB()                     <i class="conum" data-value="2"></i><b>(2)</b>

def d = c.withTraits A, B           <i class="conum" data-value="3"></i><b>(3)</b>

d.methodFromA()                     <i class="conum" data-value="4"></i><b>(4)</b>

d.methodFromB()                     <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>call to <code>methodFromA</code> will fail because <code>C</code> doesn&#8217;t implement <code>A</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>call to <code>methodFromB</code> will fail because <code>C</code> doesn&#8217;t implement <code>B</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>withTrait</code> will wrap <code>c</code> into something which implements <code>A</code> and <code>B</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td><code>methodFromA</code> will now pass because <code>d</code> implements <code>A</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td><code>methodFromB</code> will now pass because <code>d</code> also implements <code>B</code></td>

</tr>

</table>

</div>

<div class="admonitionblock important">

<table>

<tr>

<td class="icon">

<i class="icon-important" title="Important"></i>

</td>

<td class="content">

When coercing an object to multiple traits, the result of the operation is not the same instance. It is guaranteed

that the coerced object will implement both the traits <strong>and</strong> the interfaces that the original object implements, but

the result will <strong>not</strong> be an instance of the original class.

</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_chaining_behavior">Chaining behavior</h5>

<div class="paragraph">

<p>Groovy supports the concept of <em>stackable traits</em>. The idea is to delegate from one trait to the other if the current trait

is not capable of handling a message. To illustrate this, let&#8217;s imagine a message handler interface like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface MessageHandler {

    void on(String message, Map payload)

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Then you can compose a message handler by applying small behaviors. For example, let&#8217;s define a default handler in the

form of a trait:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait DefaultHandler implements MessageHandler {

    void on(String message, Map payload) {

        println "Received $message with payload $payload"

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Then any class can inherit the behavior of the default handler by implementing the trait:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class SimpleHandler implements DefaultHandler {}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Now what if you want to log all messages, in addition to the default handler? One option is to write this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class SimpleHandlerWithLogging implements DefaultHandler {

    void on(String message, Map payload) {                                  <i class="conum" data-value="1"></i><b>(1)</b>

        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>

        DefaultHandler.super.on(message, payload)                           <i class="conum" data-value="3"></i><b>(3)</b>

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>explicitly implement the <code>on</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>perform logging</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>continue by delegating to the <code>DefaultHandler</code> trait</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>This works but this approach has drawbacks:</p>

</div>

<div class="olist arabic">

<ol class="arabic">

<li>

<p>the logging logic is bound to a "concrete" handler</p>

</li>

<li>

<p>we have an explicit reference to <code>DefaultHandler</code> in the <code>on</code> method, meaning that if we happen to change the trait that our class implements, code will be broken</p>

</li>

</ol>

</div>

<div class="paragraph">

<p>As an alternative, we can write another trait which responsability is limited to logging:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait LoggingHandler implements MessageHandler {                            <i class="conum" data-value="1"></i><b>(1)</b>

    void on(String message, Map payload) {

        println "Seeing $message with payload $payload"                     <i class="conum" data-value="2"></i><b>(2)</b>

        super.on(message, payload)                                          <i class="conum" data-value="3"></i><b>(3)</b>

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the logging handler is itself a handler</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>prints the message it receives</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>then <code>super</code> makes it delegate the call to the next trait in the chain</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Then our class can be rewritten as this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class HandlerWithLogger implements DefaultHandler, LoggingHandler {}

def loggingHandler = new HandlerWithLogger()

loggingHandler.on('test logging', [:])</code></pre>

</div>

</div>

<div class="paragraph">

<p>which will print:</p>

</div>

<div class="listingblock">

<div class="content">

<pre>Seeing test logging with payload [:]

Received test logging with payload [:]</pre>

</div>

</div>

<div class="paragraph">

<p>As the priority rules imply that <code>LoggerHandler</code> wins because it is declared last, then a call to <code>on</code> will use

the implementation from <code>LoggingHandler</code>. But the latter has a call to <code>super</code>, which means the next trait in the

chain. Here, the next trait is <code>DefaultHandler</code> so <strong>both</strong> will be called:</p>

</div>

<div class="paragraph">

<p>The interest of this approach becomes more evident if we add a third handler, which is responsible for handling messages

that start with <code>say</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait SayHandler implements MessageHandler {

    void on(String message, Map payload) {

        if (message.startsWith("say")) {                                    <i class="conum" data-value="1"></i><b>(1)</b>

            println "I say ${message - 'say'}!"

        } else {

            super.on(message, payload)                                      <i class="conum" data-value="2"></i><b>(2)</b>

        }

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>a handler specific precondition</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>if the precondition is not meant, pass the message to the next handler in the chain</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Then our final handler looks like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Handler implements DefaultHandler, SayHandler, LoggingHandler {}

def h = new Handler()

h.on('foo', [:])

h.on('sayHello', [:])</code></pre>

</div>

</div>

<div class="paragraph">

<p>Which means:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>messages will first go through the logging handler</p>

</li>

<li>

<p>the logging handler calls <code>super</code> which will delegate to the next handler, which is the <code>SayHandler</code></p>

</li>

<li>

<p>if the message starts with <code>say</code>, then the hanlder consumes the message</p>

</li>

<li>

<p>if not, the <code>say</code> handler delegates to the next handler in the chain</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>This approach is very powerful because it allows you to write handlers that do not know each other and yet let you

combine them in the order you want. For example, if we execute the code, it will print:</p>

</div>

<div class="listingblock">

<div class="content">

<pre>Seeing foo with payload [:]

Received foo with payload [:]

Seeing sayHello with payload [:]

I say Hello!</pre>

</div>

</div>

<div class="paragraph">

<p>but if we move the logging handler to be the second one in the chain, the output is different:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class AlternateHandler implements DefaultHandler, LoggingHandler, SayHandler {}

h = new AlternateHandler()

h.on('foo', [:])

h.on('sayHello', [:])</code></pre>

</div>

</div>

<div class="paragraph">

<p>prints:</p>

</div>

<div class="listingblock">

<div class="content">

<pre>Seeing foo with payload [:]

Received foo with payload [:]

I say Hello!</pre>

</div>

</div>

<div class="paragraph">

<p>The reason is that now, since the <code>SayHandler</code> consumes the message without calling <code>super</code>, the logging handler is

not called anymore.</p>

</div>

<div class="sect5">

<h6 id="_semantics_of_super_inside_a_trait">Semantics of super inside a trait</h6>

<div class="paragraph">

<p>If a class implements multiple traits and that a call to an unqualified <code>super</code> is found, then:</p>

</div>

<div class="olist arabic">

<ol class="arabic">

<li>

<p>if the class implements another trait, the call delegates to the next trait in the chain</p>

</li>

<li>

<p>if there isn&#8217;t any trait left in the chain, <code>super</code> refers to the super class of the implementing class (<em>this</em>)</p>

</li>

</ol>

</div>

<div class="paragraph">

<p>For example, it is possible to decorate final classes thanks to this behavior:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Filtering {                                       <i class="conum" data-value="1"></i><b>(1)</b>

    StringBuilder append(String str) {                  <i class="conum" data-value="2"></i><b>(2)</b>

        def subst = str.replace('o','')                 <i class="conum" data-value="3"></i><b>(3)</b>

        super.append(subst)                             <i class="conum" data-value="4"></i><b>(4)</b>

    }

    String toString() { super.toString() }              <i class="conum" data-value="5"></i><b>(5)</b>

}

def sb = new StringBuilder().withTraits Filtering       <i class="conum" data-value="6"></i><b>(6)</b>

sb.append('Groovy')

assert sb.toString() == 'Grvy'                          <i class="conum" data-value="7"></i><b>(7)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>define a trait named <code>Filtering</code>, supposed to be applied on a <code>StringBuilder</code> at runtime</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>redefine the <code>append</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>remove all 'o&#8217;s from the string</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>then delegate to <code>super</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>in case <code>toString</code> is called, delegate to <code>super.toString</code></td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>runtime implementation of the <code>Filtering</code> trait on a <code>StringBuilder</code> instance</td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>the string which has been appended no longer contains the letter <code>o</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>In this example, when <code>super.append</code> is encountered, there is no other trait implemented by the target object, so the

method which is called is the original <code>append</code> method, that is to say the one from <code>StringBuilder</code>. The same trick

is used for <code>toString</code>, so that the string representation of the proxy object which is generated delegates to the

<code>toString</code> of the <code>StringBuilder</code> instance.</p>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_advanced_features">Advanced features</h5>

<div class="sect5">

<h6 id="_sam_type_coercion">SAM type coercion</h6>

<div class="paragraph">

<p>If a trait defines a single abstract method, it is candidate for SAM type coercion. For example, imagine the following

trait:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Greeter {

    String greet() { "Hello $name" }        <i class="conum" data-value="1"></i><b>(1)</b>

    abstract String getName()               <i class="conum" data-value="2"></i><b>(2)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>greet</code> method is not abstract and calls the abstract method <code>getName</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><code>getName</code> is an abstract method</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Since <code>getName</code> is the <em>single abstract method</em> in the <code>Greeter</code> trait, you can write:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Greeter greeter = { 'Alice' }               <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the closure "becomes" the implementation of the <code>getName</code> single abstract method</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>or even:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">void greet(Greeter g) { println g.greet() } <i class="conum" data-value="1"></i><b>(1)</b>

greet { 'Alice' }                           <i class="conum" data-value="2"></i><b>(2)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the greet method accepts the SAM type Greeter as parameter</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we can call it directly with a closure</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_differences_with_java_8_default_methods">Differences with Java 8 default methods</h6>

<div class="paragraph">

<p>In Java 8, interfaces can have default implementations of methods. If a class implements an interface and does not provide

an implementation for a default method, then the implementation from the interface is chosen. Traits behave the same but

with a major difference: the implementation from the trait is <strong>always</strong> used if the class declares the trait in its interface

list <strong>and</strong> that it doesn&#8217;t provide an implementation.</p>

</div>

<div class="paragraph">

<p>This feature can be used to compose behaviors in an very precise way, in case you want to override the behavior of an

already implemented method.</p>

</div>

<div class="paragraph">

<p>To illustrate the concept, let&#8217;s start with this simple example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.CompileStatic

import org.codehaus.groovy.control.CompilerConfiguration

import org.codehaus.groovy.control.customizers.ASTTransformationCustomizer

import org.codehaus.groovy.control.customizers.ImportCustomizer


class SomeTest extends GroovyTestCase {

    def config

    def shell


    void setup() {

        config = new CompilerConfiguration()

        shell = new GroovyShell(config)

    }

    void testSomething() {

        assert shell.evaluate('1+1') == 2

    }

    void otherTest() { /* ... */ }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>In this example, we create a simple test case which uses two properties (<em>config</em> and <em>shell</em>) and uses those in

multiple test methods. Now imagine that you want to test the same, but with another distinct compiler configuration.

One option is to create a subclass of <code>SomeTest</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class AnotherTest extends SomeTest {

    void setup() {

        config = new CompilerConfiguration()

        config.addCompilationCustomizers( ... )

        shell = new GroovyShell(config)

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>It works, but what if you have actually multiple test classes, and that you want to test the new configuration for all

those test classes? Then you would have to create a distinct subclass for each test class:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class YetAnotherTest extends SomeTest {

    void setup() {

        config = new CompilerConfiguration()

        config.addCompilationCustomizers( ... )

        shell = new GroovyShell(config)

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Then what you see is that the <code>setup</code> method of both tests is the same. The idea, then, is to create a trait:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait MyTestSupport {

    void setup() {

        config = new CompilerConfiguration()

        config.addCompilationCustomizers( new ASTTransformationCustomizer(CompileStatic) )

        shell = new GroovyShell(config)

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Then use it in the subclasses:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class AnotherTest extends SomeTest implements MyTestSupport {}

class YetAnotherTest extends SomeTest2 implements MyTestSupport {}

...</code></pre>

</div>

</div>

<div class="paragraph">

<p>It would allow us to dramatically reduce the boilerplate code, and reduces the risk of forgetting to change the setup

code in case we decide to change it. Even if <code>setup</code> is already implemented in the super class, since the test class declares

the trait in its interface list, the behavior will be borrowed from the trait implementation!</p>

</div>

<div class="paragraph">

<p>This feature is in particular useful when you don&#8217;t have access to the super class source code. It can be used to

mock methods or force a particular implementation of a method in a subclass. It lets you refactor your code to keep

the overriden logic in a single trait and inherit a new behavior just by implementing it. The alternative, of course,

is to override the method in <strong>every</strong> place you would have used the new code.</p>

</div>

<div class="admonitionblock important">

<table>

<tr>

<td class="icon">

<i class="icon-important" title="Important"></i>

</td>

<td class="content">

It&#8217;s worth noting that if you use runtime traits, the methods from the trait are <strong>always</strong> preferred to those of the proxied

object:

</td>

</tr>

</table>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Person {

    String name                                         <i class="conum" data-value="1"></i><b>(1)</b>

}

trait Bob {

    String getName() { 'Bob' }                          <i class="conum" data-value="2"></i><b>(2)</b>

}


def p = new Person(name: 'Alice')

assert p.name == 'Alice'                                <i class="conum" data-value="3"></i><b>(3)</b>

def p2 = p as Bob                                       <i class="conum" data-value="4"></i><b>(4)</b>

assert p2.name == 'Bob'                                 <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>Person</code> class defines a <code>name</code> property which results in a <code>getName</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><code>Bob</code> is a trait which defines <code>getName</code> as returning <code>Bob</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the default object will return <em>Alice</em></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td><code>p2</code> coerces <code>p</code> into <code>Bob</code> at runtime</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td><code>getName</code> returns <em>Bob</em> because <code>getName</code> is taken from the <strong>trait</strong></td>

</tr>

</table>

</div>

<div class="admonitionblock important">

<table>

<tr>

<td class="icon">

<i class="icon-important" title="Important"></i>

</td>

<td class="content">

Again, don&#8217;t forget that dynamic trait coercion returns a distinct object which only implements the original

interfaces, as well as the traits.

</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_differences_with_mixins">Differences with mixins</h5>

<div class="paragraph">

<p>There are several conceptual differences with mixins, as they are available in Groovy. Note that we are talking about

runtime mixins, not the @Mixin annotation which is deprecated in favour of traits.</p>

</div>

<div class="paragraph">

<p>First of all, methods defined in a trait are visible in bytecode:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>internally, the trait is represented as an interface (without default methods) and several helper classes</p>

</li>

<li>

<p>this means that an object implementing a trait effectively implements an <em>interface</em></p>

</li>

<li>

<p>those methods are visible from Java</p>

</li>

<li>

<p>they are compatible with type checking and static compilation</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>Methods added through a mixin are, on the contrary, only visible at runtime:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class A { String methodFromA() { 'A' } }        <i class="conum" data-value="1"></i><b>(1)</b>

class B { String methodFromB() { 'B' } }        <i class="conum" data-value="2"></i><b>(2)</b>

A.metaClass.mixin B                             <i class="conum" data-value="3"></i><b>(3)</b>

def o = new A()

assert o.methodFromA() == 'A'                   <i class="conum" data-value="4"></i><b>(4)</b>

assert o.methodFromB() == 'B'                   <i class="conum" data-value="5"></i><b>(5)</b>

assert o instanceof A                           <i class="conum" data-value="6"></i><b>(6)</b>

assert !(o instanceof B)                        <i class="conum" data-value="7"></i><b>(7)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>class <code>A</code> defines <code>methodFromA</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>class <code>B</code> defines <code>methodFromB</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>mixin B into A</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>we can call <code>methodFromA</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>we can also call <code>methodFromB</code></td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>the object is an instance of <code>A</code></td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>but it&#8217;s <strong>not</strong> an instanceof <code>B</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The last point is actually a very important and illustrates a place where mixins have an advantage over traits: the instances

are <strong>not</strong> modified, so if you mixin some class into another, there isn&#8217;t a third class generated, and methods which respond to

A will continue responding to A even if mixed in.</p>

</div>

</div>

<div class="sect4">

<h5 id="_static_methods_properties_and_fields">Static methods, properties and fields</h5>

<div class="admonitionblock warning">

<table>

<tr>

<td class="icon">

<i class="icon-warning" title="Warning"></i>

</td>

<td class="content">

The following instructions are subject to caution. Static member support is work in progress and still experimental. The

information below is valid for 2.3.6 only.

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>It is possible to define static methods in a trait, but it comes with numerous limitations:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>traits with static methods cannot be compiled statically or type checked. All static methods/properties/field are accessed dynamically (it&#8217;s a limitation from the JVM).</p>

</li>

<li>

<p>the trait is interpreted as a <em>template</em> for the implementing class, which means that each implementing class will get its own static methods/properties/methods. So a

static member declared on a trait doesn&#8217;t belong to the <code>Trait</code>, but to it&#8217;s implementing class.</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>Let&#8217;s start with a simple example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait TestHelper {

    public static boolean CALLED = false        <i class="conum" data-value="1"></i><b>(1)</b>

    static void init() {                        <i class="conum" data-value="2"></i><b>(2)</b>

        CALLED = true                           <i class="conum" data-value="3"></i><b>(3)</b>

    }

}

class Foo implements TestHelper {}

Foo.init()                                      <i class="conum" data-value="4"></i><b>(4)</b>

assert Foo.TestHelper__CALLED                   <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the static field is declared in the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>a static method is also declared in the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the static field is updated <em>within</em> the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>a static method <em>init</em> is made available to the implementing class</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>the static field is <em>remapped</em> to avoid the diamond issue</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>As usual, it is not recommanded to use public fields. Anyway, should you want this, you must understand that the following code would fail:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Foo.CALLED = true</code></pre>

</div>

</div>

<div class="paragraph">

<p>because there is <em>no</em> static field <em>CALLED</em> defined on the trait itself. Likewise, if you have two distinct implementing classes, each one gets a distinct static field:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Bar implements TestHelper {}              <i class="conum" data-value="1"></i><b>(1)</b>

class Baz implements TestHelper {}              <i class="conum" data-value="2"></i><b>(2)</b>

Bar.init()                                      <i class="conum" data-value="3"></i><b>(3)</b>

assert Bar.TestHelper__CALLED                   <i class="conum" data-value="4"></i><b>(4)</b>

assert !Baz.TestHelper__CALLED                  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>class <code>Bar</code> implements the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>class <code>Baz</code> also implements the trait</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>init</code> is only called on <code>Bar</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>the static field <code>CALLED</code> on <code>Bar</code> is updated</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>but the static field <code>CALLED</code> on <code>Baz</code> is not, because it is <strong>distinct</strong></td>

</tr>

</table>

</div>

</div>

<div class="sect4">

<h5 id="_inheritance_of_state_gotchas">Inheritance of state gotchas</h5>

<div class="paragraph">

<p>We have seen that traits are stateful. It is possible for a trait to define fields or properties, but when a class implements a trait, it gets those fields/properties on

a per-trait basis. So consider the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait IntCouple {

    int x = 1

    int y = 2

    int sum() { x+y }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>The trait defines two properties, <code>x</code> and <code>y</code>, as well as a <code>sum</code> method. Now let&#8217;s create a class which implements the trait:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class BaseElem implements IntCouple {

    int f() { sum() }

}

def base = new BaseElem()

assert base.f() == 3</code></pre>

</div>

</div>

<div class="paragraph">

<p>The result of calling <code>f</code> is <code>3</code>, because <code>f</code> delegates to <code>sum</code> in the trait, which has state. But what if we write this instead?</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Elem implements IntCouple {

    int x = 3                                       <i class="conum" data-value="1"></i><b>(1)</b>

    int y = 4                                       <i class="conum" data-value="2"></i><b>(2)</b>

    int f() { sum() }                               <i class="conum" data-value="3"></i><b>(3)</b>

}

def elem = new Elem()</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>Override property <code>x</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>Override property <code>y</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>Call <code>sum</code> from trait</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>If you call <code>elem.f()</code>, what is the expected output? Actually it is:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert elem.f() == 3</code></pre>

</div>

</div>

<div class="paragraph">

<p>The reason is that the <code>sum</code> method accesses the <em>fields</em> of the trait. So it is using the <code>x</code> and <code>y</code> values defined

in the trait. If you want to use the values from the implementing class, then you need to derefencence fields by using

getters and setters, like in this last example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait IntCouple {

    int x = 1

    int y = 2

    int sum() { getX()+getY() }

}


class Elem implements IntCouple {

    int x = 3

    int y = 4

    int f() { sum() }

}

def elem = new Elem()

assert elem.f() == 7</code></pre>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_limitations">Limitations</h5>

<div class="sect5">

<h6 id="_compatibility_with_ast_transformations">Compatibility with AST transformations</h6>

<div class="admonitionblock caution">

<table>

<tr>

<td class="icon">

<i class="icon-caution" title="Caution"></i>

</td>

<td class="content">

Traits are not officially compatible with AST transformations. Some of them, like <code>@CompileStatic</code> will be applied

on the trait itself (not on implementing classes), while others will apply on both the implementing class and the trait.

There is absolutely no guarantee that an AST transformation will run on a trait as it does on a regular class, so use it

at your own risk!

</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_prefix_and_postfix_operations">Prefix and postfix operations</h6>

<div class="paragraph">

<p>Within traits, prefix and postfix operations are not allowed if they update a field of the trait:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">trait Counting {

    int x

    void inc() {

        x++                             <i class="conum" data-value="1"></i><b>(1)</b>

    }

    void dec() {

        --x                             <i class="conum" data-value="2"></i><b>(2)</b>

    }

}

class Counter implements Counting {}

def c = new Counter()

c.inc()</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>x</code> is defined within the trait, postfix increment is not allowed</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><code>x</code> is defined within the trait, prefix decrement is not allowed</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>A workaround is to use the <code>+=</code> operator instead.

:leveloffset: 0</p>

</div>

</div>

</div>

</div>

<div class="sect3">

<h4 id="_closures_tbd">1.4.3. Closures (TBD)</h4>

<div class="paragraph">

<p>This chapter covers Groovy Closures.</p>

</div>

<div class="sect4">

<h5 id="_syntax_tbd">Syntax (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_parameters_tbd">Parameters (TBD)</h5>

<div class="sect5">

<h6 id="_normal_parameters_tbd">Normal parameters (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_implicit_parameter_tbd">Implicit parameter (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_default_parameter_tbd">Default parameter (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_varargs_tbd_2">Varargs (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_delegation_strategy_tbd">Delegation strategy (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_closures_in_gstrings_tbd">Closures in GStrings (TBD)</h5>


</div>

<div class="sect4">

<h5 id="_functional_programming_tbd">Functional programming (TBD)</h5>

<div class="sect5">

<h6 id="_currying_tbd">Currying (TBD)</h6>

<div class="sect6">

<h7 id="_left_currying_tbd">Left currying (TBD)</h7>


</div>

<div class="sect6">

<h7 id="_right_currying_tbd">Right currying (TBD)</h7>


</div>

<div class="sect6">

<h7 id="_index_based_currying_tbd">Index based currying (TBD)</h7>


</div>

</div>

<div class="sect5">

<h6 id="_memoization_tbd">Memoization (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_composition_tbd">Composition (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_trampoline_tbd">Trampoline (TBD)</h6>


</div>

</div>

</div>

<div class="sect3">

<h4 id="_semantics">1.4.4. Semantics</h4>

<div class="paragraph">

<p>This chapter covers the semantics of the Groovy programming language.</p>

</div>

<div class="sect4">

<h5 id="_statements">Statements</h5>

<div class="sect5">

<h6 id="_variable_definition">Variable definition</h6>

<div class="paragraph">

<p>Variables can be defined using either their type (like <code>String</code>) or by using the keyword <code>def</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String x

def o</code></pre>

</div>

</div>

<div class="paragraph">

<p><code>def</code> is a replacement for a type name. In variable definitions it is used to indicate that you don&#8217;t care about the type. In variable definitions it is mandatory to either provide a type name explicitly or to use "def" in replacement. This is needed to the make variable definitions detectable for the Groovy parser.</p>

</div>

<div class="paragraph">

<p>You can think of <code>def</code> as an alias of <code>Object</code> and you will understand it in an instant.</p>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

Variable definition types can be refined by using generics, like in <code>List&lt;String&gt; names</code>.

To learn more about the generics support, please read the <a href="groovy_language_specification.html#generics">generics section</a>.

</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="_variable_assignment">Variable assignment</h6>

<div class="paragraph">

<p>You can assign values to variables for later use. Try the following:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">x = 1

println x


x = new java.util.Date()

println x


x = -3.1499392

println x


x = false

println x


x = "Hi"

println x</code></pre>

</div>

</div>

<div class="sect6">

<h7 id="_multiple_assignment">Multiple assignment</h7>

<div class="paragraph">

<p>Groovy supports multiple assignment, i.e. where multiple variables can be assigned at once, e.g.:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def (a, b, c) = [10, 20, 'foo']

assert a == 10 &amp;&amp; b == 20 &amp;&amp; c == 'foo'</code></pre>

</div>

</div>

<div class="paragraph">

<p>You can provide types as part of the declaration if you wish:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def (int i, String j) = [10, 'foo']

assert i == 10 &amp;&amp; j == 'foo'</code></pre>

</div>

</div>

<div class="paragraph">

<p>As well as used when declaring variables it also applies to existing variables:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def nums = [1, 3, 5]

def a, b, c

(a, b, c) = nums

assert a == 1 &amp;&amp; b == 3 &amp;&amp; c == 5</code></pre>

</div>

</div>

<div class="paragraph">

<p>The syntax works for arrays as well as lists, as well as methods that return either of these:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def (_, month, year) = "18th June 2009".split()

assert "In $month of $year" == 'In June of 2009'</code></pre>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_overflow_and_underflow">Overflow and Underflow</h7>

<div class="paragraph">

<p>If the left hand side has too many variables, excess ones are filled with null&#8217;s:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def (a, b, c) = [1, 2]

assert a == 1 &amp;&amp; b == 2 &amp;&amp; c == null</code></pre>

</div>

</div>

<div class="paragraph">

<p>If the right hand side has too many variables, the extra ones are ignored:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def (a, b) = [1, 2, 3]

assert a == 1 &amp;&amp; b == 2</code></pre>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_object_destructuring_with_multiple_assignment">Object destructuring with multiple assignment</h7>

<div class="paragraph">

<p>In the section describing the various <a href="groovy_language_specification.html#groovy-operators">Groovy operators</a>,

the case of the <a href="groovy_language_specification.html#subscript-operator">subscript operator</a> has been covered,

explaining how you can override the <code>getAt()</code>/<code>putAt()</code> method.</p>

</div>

<div class="paragraph">

<p>With this technique, we can combine multiple assignments and the subscript operator methods to implement <em>object destructuring</em>.</p>

</div>

<div class="paragraph">

<p>Consider the following immutable <code>Coordinates</code> class, containing a pair of longitude and latitude doubles,

and notice our implementation of the <code>getAt()</code> method:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@Immutable

class Coordinates {

    double latitude

    double longitude


    double getAt(int idx) {

        if (idx == 0) latitude

        else if (idx == 1) longitude

        else throw new Exception("Wrong coordinate index, use 0 or 1")

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Now let&#8217;s instantiate this class and destructure its longitude and latitude:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def coordinates = new Coordinates(latitude: 43.23, longitude: 3.67) <i class="conum" data-value="1"></i><b>(1)</b>


def (la, lo) = coordinates                                          <i class="conum" data-value="2"></i><b>(2)</b>


assert la == 43.23                                                  <i class="conum" data-value="3"></i><b>(3)</b>

assert lo == 3.67</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>we create an instance of the <code>Coordinates</code> class</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>then, we use a multiple assignment to get the individual longitude and latitude values</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>and we can finally assert their values.</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_control_structures_wip">Control structures (WIP)</h6>

<div class="sect6">

<h7 id="_conditional_structures">Conditional structures</h7>

<div class="sect7">

<h8 id="_if_else">if / else</h8>

<div class="paragraph">

<p>Groovy supports the usual if - else syntax from Java</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def x = false

def y = false


if ( !x ) {

    x = true

}


assert x == true


if ( x ) {

    x = false

} else {

    y = true

}


assert x == y</code></pre>

</div>

</div>

<div class="paragraph">

<p>Groovy also supports the normal Java "nested" if then else if syntax:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">if ( ... ) {

    ...

} else if (...) {

    ...

} else {

    ...

}</code></pre>

</div>

</div>

</div>

<div class="sect7">

<h8 id="_switch_case">switch / case</h8>

<div class="paragraph">

<p>The switch statement in Groovy is backwards compatible with Java code; so you can fall through cases sharing the same code for multiple matches.</p>

</div>

<div class="paragraph">

<p>One difference though is that the Groovy switch statement can handle any kind of switch value and different kinds of matching can be performed.</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def x = 1.23

def result = ""


switch ( x ) {

    case "foo":

        result = "found foo"

        // lets fall through


    case "bar":

        result += "bar"


    case [4, 5, 6, 'inList']:

        result = "list"

        break


    case 12..30:

        result = "range"

        break


    case Integer:

        result = "integer"

        break


    case Number:

        result = "number"

        break


    case ~/fo*/: // toString() representation of x matches the pattern?

        result = "foo regex"

        break


    case { it &lt; 0 }: // or { x &lt; 0 }

        result = "negative"

        break


    default:

        result = "default"

}


assert result == "number"</code></pre>

</div>

</div>

<div class="paragraph">

<p>Switch supports the following kinds of comparisons:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>Class case values matches if the switch value is an instance of the class</p>

</li>

<li>

<p>Regular expression case values match if the <code>toString()</code> representation of the switch value matches the regex</p>

</li>

<li>

<p>Collection case values match if the switch value is contained in the collection. This also includes ranges (since they are Lists)</p>

</li>

<li>

<p>Closure case values match if the calling the closure returns a result which is true according to the <a href="groovy_language_specification.html#Groovy-Truth">Groovy truth</a></p>

</li>

<li>

<p>If none of the above are used then the case value matches if the case value equals the switch value</p>

</li>

</ul>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

<code>default</code> must go at the end of the switch/case. While in Java the default can be placed anywhere in the switch/case, the default in Groovy is used more as an else than assigning a default case.

</td>

</tr>

</table>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

when using a closure case value, the default <code>it</code> parameter is actually the switch value (in our example, variable <code>x</code>)

</td>

</tr>

</table>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_looping_structures">Looping structures</h7>

<div class="sect7">

<h8 id="_classic_for_loop">Classic for loop</h8>

<div class="paragraph">

<p>Groovy supports the standard Java / C for loop:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String message = ''

for (int i = 0; i &lt; 5; i++) {

    message += 'Hi '

}

assert message == 'Hi Hi Hi Hi Hi '</code></pre>

</div>

</div>

</div>

<div class="sect7">

<h8 id="_for_in_loop">for in loop</h8>

<div class="paragraph">

<p>The for loop in Groovy is much simpler and works with any kind of array, collection, Map, etc.</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">// iterate over a range

def x = 0

for ( i in 0..9 ) {

    x += i

}

assert x == 45


// iterate over a list

x = 0

for ( i in [0, 1, 2, 3, 4] ) {

    x += i

}

assert x == 10


// iterate over an array

def array = (0..4).toArray()

x = 0

for ( i in array ) {

    x += i

}

assert x == 10


// iterate over a map

def map = ['abc':1, 'def':2, 'xyz':3]

x = 0

for ( e in map ) {

    x += e.value

}

assert x == 6


// iterate over values in a map

x = 0

for ( v in map.values() ) {

    x += v

}

assert x == 6


// iterate over the characters in a string

def text = "abc"

def list = []

for (c in text) {

    list.add(c)

}

assert list == ["a", "b", "c"]</code></pre>

</div>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

Groovy also supports the Java colon variation with colons: <code>for (char c : text) {}</code>,

where the type of the variable is mandatory.

</td>

</tr>

</table>

</div>

</div>

<div class="sect7">

<h8 id="_while_loop">while loop</h8>

<div class="paragraph">

<p>Groovy supports the usual while {&#8230;} loops like Java:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def x = 0

def y = 5


while ( y-- &gt; 0 ) {

    x++

}


assert x == 5</code></pre>

</div>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_exception_handling">Exception handling</h7>

<div class="paragraph">

<p>Exception handling is the same as Java.</p>

</div>

</div>

<div class="sect6">

<h7 id="_try_catch_finally">try / catch / finally</h7>

<div class="paragraph">

<p>You can specify a complete <code>try-catch-finally</code>, a <code>try-catch</code>, or a <code>try-finally</code> set of blocks.</p>

</div>

<div class="admonitionblock note">

<table>

<tr>

<td class="icon">

<i class="icon-note" title="Note"></i>

</td>

<td class="content">

Braces are required around each block&#8217;s body.

</td>

</tr>

</table>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">try {

    'moo'.toLong()   // this will generate an exception

    assert false     // asserting that this point should never be reached

} catch ( e ) {

    assert e in NumberFormatException

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>We can put code within a <em>finally</em> clause following a matching <em>try</em> clause, so that regardless of whether the code in the <em>try</em> clause throws an exception, the code in the finally clause will always execute:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def z

try {

    def i = 7, j = 0

    try {

        def k = i / j

        assert false        //never reached due to Exception in previous line

    } finally {

        z = 'reached here'  //always executed even if Exception thrown

    }

} catch ( e ) {

    assert e in ArithmeticException

    assert z == 'reached here'

}</code></pre>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_multi_catch">Multi-catch</h7>

<div class="paragraph">

<p>With the multi catch block (since Groovy 2.0), we&#8217;re able to define several exceptions to be catch and treated by the same catch block:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">try {

    /* ... */

} catch ( IOException | NullPointerException e ) {

    /* one block to handle 2 exceptions */

}</code></pre>

</div>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_power_assertion_tbd">Power assertion (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_labeled_statements_tbd">Labeled statements (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_expressions_tbd">Expressions (TBD)</h5>

<div class="sect5">

<h6 id="_gpath_expressions_tbd">GPath expressions (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_promotion_and_coercion_tbd">Promotion and coercion (TBD)</h5>

<div class="sect5">

<h6 id="_number_promotion_tbd">Number promotion (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_closure_to_type_coercion">Closure to type coercion</h6>

<div class="sect6">

<h7 id="_assigning_a_closure_to_a_sam_type">Assigning a closure to a SAM type</h7>

<div class="paragraph">

<p>A SAM type is a type which defines a single abstract method. This includes:</p>

</div>

<div class="listingblock">

<div class="title">Functional interfaces</div>

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface Predicate&lt;T&gt; {

    boolean accept(T obj)

}</code></pre>

</div>

</div>

<div class="listingblock">

<div class="title">Abstract classes with single abstract method</div>

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">abstract class Greeter {

    abstract String getName()

    void greet() {

        println "Hello, $name"

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Any closure can be converted into a SAM type using the <code>as</code> operator:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Predicate filter = { it.contains 'G' } as Predicate

assert filter.accept('Groovy') == true


Greeter greeter = { 'Groovy' } as Greeter

greeter.greet()</code></pre>

</div>

</div>

<div class="paragraph">

<p>However, the <code>as Type</code> expression is optional since Groovy 2.2.0. You can omit it and simply write:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Predicate filter = { it.contains 'G' }

assert filter.accept('Groovy') == true


Greeter greeter = { 'Groovy' }

greeter.greet()</code></pre>

</div>

</div>

<div class="paragraph">

<p>which means you are also allowed to use method pointers, as shown in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">boolean doFilter(String s) { s.contains('G') }


Predicate filter = this.&amp;doFilter

assert filter.accept('Groovy') == true


Greeter greeter = GroovySystem.&amp;getVersion

greeter.greet()</code></pre>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_calling_a_method_accepting_a_sam_type_with_a_closure">Calling a method accepting a SAM type with a closure</h7>

<div class="paragraph">

<p>The second and probably more important use case for closure to SAM type coercion is calling a method which accepts

a SAM type. Imagine the following method:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">public &lt;T&gt; List&lt;T&gt; filter(List&lt;T&gt; source, Predicate&lt;T&gt; predicate) {

    source.findAll { predicate.accept(it) }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Then you can call it with a closure, without having to create an explicit implementation of the interface:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert filter(['Java','Groovy'], { it.contains 'G'} as Predicate) == ['Groovy']</code></pre>

</div>

</div>

<div class="paragraph">

<p>But since Groovy 2.2.0, you are also able to omit the explicit coercion and call the method as if it used a closure:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert filter(['Java','Groovy']) { it.contains 'G'} == ['Groovy']</code></pre>

</div>

</div>

<div class="paragraph">

<p>As you can see, this has the advantage of letting you use the closure syntax for method calls, that is to say put the

closure outside of the parenthesis, improving the readability of your code.</p>

</div>

</div>

<div class="sect6">

<h7 id="_closure_to_arbitrary_type_coercion">Closure to arbitrary type coercion</h7>

<div class="paragraph">

<p>In addition to SAM types, a closure can be coerced to any type and in particular interfaces. Let&#8217;s define the

following interface:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface FooBar {

    int foo()

    void bar()

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>You can coerce a closure into the interface using the <code>as</code> keyword:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def impl = { println 'ok'; 123 } as FooBar</code></pre>

</div>

</div>

<div class="paragraph">

<p>This produces a class for which all methods are implemented using the closure:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert impl.foo() == 123

impl.bar()</code></pre>

</div>

</div>

<div class="paragraph">

<p>But it is also possible to coerce a closure to any class. For example, we can replace the <code>interface</code> that we defined

with <code>class</code> without changing the assertions:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class FooBar {

    int foo() { 1 }

    void bar() { println 'bar' }

}


def impl = { println 'ok'; 123 } as FooBar


assert impl.foo() == 123

impl.bar()</code></pre>

</div>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_map_to_type_coercion">Map to type coercion</h6>

<div class="paragraph">

<p>Usually using a single closure to implement an interface or a class with multiple methods is not the way to go. As an

alternative, Groovy allows you to coerce a map into an interface or a class. In that case, keys of the map are

interpreted as method names, while the values are the method implementation. The following example illustrates the

coercion of a map into an <code>Iterator</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def map

map = [

  i: 10,

  hasNext: { map.i &gt; 0 },

  next: { map.i-- },

]

def iter = map as Iterator</code></pre>

</div>

</div>

<div class="paragraph">

<p>Of course this is a rather contrived example, but illustrates the concept. You only need to implement those methods

that are actually called, but if a method is called that doesn&#8217;t exist in the map a <code>MissingMethodException</code> or an

<code>UnsupportedOperationException</code> is thrown, depending on the arguments passed to the call,

as in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface X {

    void f()

    void g(int n)

    void h(String s, int n)

}


x = [ f: {println "f called"} ] as X

x.f() // method exists

x.g() // MissingMethodException here

x.g(5) // UnsupportedOperationException here</code></pre>

</div>

</div>

<div class="paragraph">

<p>The type of the exception depends on the call itself:</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>MissingMethodException</code> if the arguments of the call do not match those from the interface/class</p>

</li>

<li>

<p><code>UnsupportedOperationException</code> if the arguments of the call match one of the overloaded methods of the interface/class</p>

</li>

</ul>

</div>

</div>

<div class="sect5">

<h6 id="_string_to_enum_coercion">String to enum coercion</h6>

<div class="paragraph">

<p>Groovy allows transparent <code>String</code> (or <code>GString</code>) to enum values coercion. Imagine you define the following enum:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">enum State {

    up,

    down

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>then you can assign a string to the enum without having to use an explicit <code>as</code> coercion:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">State st = 'up'

assert st == State.up</code></pre>

</div>

</div>

<div class="paragraph">

<p>It is also possible to use a <code>GString</code> as the value:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def val = "up"

State st = "${val}"

assert st == State.up</code></pre>

</div>

</div>

<div class="paragraph">

<p>However, this would throw a runtime error (<code>IllegalArgumentException</code>):</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">State st = 'not an enum value'</code></pre>

</div>

</div>

<div class="paragraph">

<p>Note that it is also possible to use implicit coercion in switch statements:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">State switchState(State st) {

    switch (st) {

        case 'up':

            return State.down // explicit constant

        case 'down':

            return 'up' // implicit coercion for return types

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>in particular, see how the <code>case</code> use string constants. But if you call a method that uses an enum with a <code>String</code>

argument, you still have to use an explicit <code>as</code> coercion:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">assert switchState('up' as State) == State.down

assert switchState(State.down) == State.up</code></pre>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_custom_type_coercion">Custom type coercion</h6>

<div class="paragraph">

<p>It is possible for a class to define custom coercion strategies by implementing the <code>asType</code> method. Custom coercion

is invoked using the <code>as</code> operator and is never implicit. As an example,

imagine you defined two classes, <code>Polar</code> and <code>Cartesian</code>, like in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Polar {

    double r

    double phi

}

class Cartesian {

   double x

   double y

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>And that you want to convert from polar coordinates to cartesian coordinates. One way of doing this is to define

the <code>asType</code> method in the <code>Polar</code> class:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def asType(Class target) {

    if (Cartesian==target) {

        return new Cartesian(x: r*cos(phi), y: r*sin(phi))

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>which allows you to use the <code>as</code> coercion operator:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def sigma = 1E-16

def polar = new Polar(r:1.0,phi:PI/2)

def cartesian = polar as Cartesian

assert abs(cartesian.x-sigma) &lt; sigma</code></pre>

</div>

</div>

<div class="paragraph">

<p>Putting it all together, the <code>Polar</code> class looks like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Polar {

    double r

    double phi

    def asType(Class target) {

        if (Cartesian==target) {

            return new Cartesian(x: r*cos(phi), y: r*sin(phi))

        }

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>but it is also possible to define <code>asType</code> outside of the <code>Polar</code> class, which can be practical if you want to define

custom coercion strategies for "closed" classes or classes for which you don&#8217;t own the source code, for example using

a metaclass:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Polar.metaClass.asType = { Class target -&gt;

    if (Cartesian==target) {

        return new Cartesian(x: r*cos(phi), y: r*sin(phi))

    }

}</code></pre>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_class_literals_vs_variables_and_the_as_operator">Class literals vs variables and the as operator</h6>

<div class="paragraph">

<p>Using the <code>as</code> keyword is only possible if you have a static reference to a class, like in the following code:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface Greeter {

    void greet()

}

def greeter = { println 'Hello, Groovy!' } as Greeter // Greeter is known statically

greeter.greet()</code></pre>

</div>

</div>

<div class="paragraph">

<p>But what if you get the class by reflection, for example by calling <code>Class.forName</code>?</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Class clazz = Class.forName('Greeter')</code></pre>

</div>

</div>

<div class="paragraph">

<p>Trying to use the reference to the class with the <code>as</code> keyword would fail:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">greeter = { println 'Hello, Groovy!' } as clazz

// throws:

// unable to resolve class clazz

// @ line 9, column 40.

//   greeter = { println 'Hello, Groovy!' } as clazz</code></pre>

</div>

</div>

<div class="paragraph">

<p>It is failing because the <code>as</code> keyword only works with class literals. Instead, you need to call the <code>asType</code> method:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">greeter = { println 'Hello, Groovy!' }.asType(clazz)

greeter.greet()</code></pre>

</div>

</div>

</div>

</div>

<div class="sect4">

<h5 id="_optionality_tbd">Optionality (TBD)</h5>

<div class="sect5">

<h6 id="_optional_parentheses_tbd">Optional parentheses (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_optional_semicolons_tbd">Optional semicolons (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_optional_return_keyword_tbd">Optional return keyword (TBD)</h6>


</div>

<div class="sect5">

<h6 id="_optional_public_keyword_tbd">Optional public keyword (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="Groovy-Truth">The Groovy Truth (TBD)</h5>

<div class="sect5">

<h6 id="_customizing_the_truth_with_asboolean_methods_tbd">Customizing the truth with asBoolean() methods (TBD)</h6>


</div>

</div>

<div class="sect4">

<h5 id="_typing_wip">Typing (WIP)</h5>

<div class="sect5">

<h6 id="_optional_typing">Optional typing</h6>

<div class="paragraph">

<p>Optional typing is the idea that a program can work even if you don&#8217;t put an explicit type on a variable. Being a dynamic

language, Groovy naturally implements that feature, for example when you declare a variable:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String aString = 'foo'                      <i class="conum" data-value="1"></i><b>(1)</b>

assert aString.toUpperCase()                <i class="conum" data-value="2"></i><b>(2)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>foo</code> is declared using an explicit type, <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we can call the <code>toUpperCase</code> method on a <code>String</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Groovy will let you write this instead:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def aString = 'foo'                         <i class="conum" data-value="1"></i><b>(1)</b>

assert aString.toUpperCase()                <i class="conum" data-value="2"></i><b>(2)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>foo</code> is declared using <code>def</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we can still call the <code>toUpperCase</code> method, because the type of <code>aString</code> is resolved at runtime</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>So it doesn&#8217;t matter that you use an explicit type here. It is in particular interesting when you combine this feature

with <a href="groovy_language_specification.html#typechecking">static type checking</a>, because the type checker performs type inference.</p>

</div>

<div class="paragraph">

<p>Likewise, Groovy doesn&#8217;t make it mandatory to declare the types of a parameter in a method:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String concat(String a, String b) {

    a+b

}

assert concat('foo','bar') == 'foobar'</code></pre>

</div>

</div>

<div class="paragraph">

<p>can be rewritten using <code>def</code> as both return type and parameter types, in order to take advantage of duck typing, as

illustrated in this example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def concat(def a, def b) {                              <i class="conum" data-value="1"></i><b>(1)</b>

    a+b

}

assert concat('foo','bar') == 'foobar'                  <i class="conum" data-value="2"></i><b>(2)</b>

assert concat(1,2) == 3                                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>both the return type and the parameter types use <code>def</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>it makes it possible to use the method with <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>but also with <code>int`s since the `plus</code> method is defined</td>

</tr>

</table>

</div>

<div class="admonitionblock tip">

<table>

<tr>

<td class="icon">

<i class="icon-tip" title="Tip"></i>

</td>

<td class="content">

Using the <code>def</code> keyword here is recommanded to describe the intent of a method which is supposed to work on any

type, but technically, we could use <code>Object</code> instead and the result would be the same: <code>def</code> is, in Groovy, strictly

equivalent to using <code>Object</code>.

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Eventually, the type can be removed altogether from both the return type and the descriptor. But if you want to remove

it from the return type, you then need to add an explicit modifier for the method, so that the compiler can make a difference

between a method declaration and a method call, like illustrated in this example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">private concat(a,b) {                                   <i class="conum" data-value="1"></i><b>(1)</b>

    a+b

}

assert concat('foo','bar') == 'foobar'                  <i class="conum" data-value="2"></i><b>(2)</b>

assert concat(1,2) == 3                                 <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>if we want to omit the return type, an explicit modifier has to be set.</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>it is still possible to use the method with <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>and also with `int`s</td>

</tr>

</table>

</div>

<div class="admonitionblock tip">

<table>

<tr>

<td class="icon">

<i class="icon-tip" title="Tip"></i>

</td>

<td class="content">

Omitting types is in general considered a bad practice in method parameters or method return types for public APIs.

While using <code>def</code> in a local variable is not really a problem because the visibility of the variable is limited to the

method itself, while set on a method parameter, <code>def</code> will be converted to <code>Object</code> in the method signature, making it

difficult for users to know which is the expected type of the arguments. This means that you should limit this to cases

where you are explicitly relying on duck typing.

</td>

</tr>

</table>

</div>

</div>

<div class="sect5">

<h6 id="static-type-checking">Static type checking</h6>

<div class="paragraph">

<p>By default, Groovy performs minimal type checking at compile time. Since it is primarily a dynamic language,

most checks that a static compiler would normally do aren&#8217;t possible at compile time. A method added via runtime

metaprogramming might alter a class or object&#8217;s runtime behavior. Let&#8217;s illustrate why in the

following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Person {                                                          <i class="conum" data-value="1"></i><b>(1)</b>

    String firstName

    String lastName

}

def p = new Person(firstName: 'Raymond', lastName: 'Devos')             <i class="conum" data-value="2"></i><b>(2)</b>

assert p.formattedName == 'Raymond Devos'                               <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>Person</code> class only defines two properties, <code>firstName</code> and <code>lastName</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we can create an instance of Person</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>and call a method named <code>formattedName</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>It is quite common in dynamic languages for code such as the above example not to throw any error. How can this be?

In Java, this would typically fail at compile time. However, in Groovy, it will not fail at compile time, and if coded

correctly, will also not fail at runtime. In fact, to make this work at runtime, <strong>one</strong> possibility is to rely on

runtime metaprogramming. So just adding this line after the declaration of the <code>Person</code> class is enough:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Person.metaClass.getFormattedName = { "$delegate.firstName $delegate.lastName" }</code></pre>

</div>

</div>

<div class="paragraph">

<p>This means that in general, in Groovy, you can&#8217;t make any assumption about the type of an object beyond its declaration

type, and even if you know it, you can&#8217;t determine at compile time what method will be called, or which property will

be retrieved, and this is <strong>perfectly fine</strong>. This is how dynamic languages work, and it has a lot of interest.</p>

</div>

<div class="paragraph">

<p>However, if your program doesn&#8217;t rely on dynamic features and that you come from the static world (in particular, from

a Java mindset), not catching such "errors" at compile time can be surprising. As we have seen in the previous example,

the compiler cannot be sure this is an error. To make it aware that it is, you have to explicitly instruct the compiler

that you are switching to a type checked mode. This can be done by annotating a class or a method with <code>@groovy.lang.TypeChecked</code>.</p>

</div>

<div class="paragraph">

<p>When type checking is activated, the compiler performs much more work:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>type inference is activated, meaning that even if you use <code>def</code> on a local variable for example, the type checker will be

able to infer the type of the variable from the assignments</p>

</li>

<li>

<p>method calls are resolved at compile time, meaning that if a method is not declared on a class, the compiler will throw an error</p>

</li>

<li>

<p>in general, all the compile time errors that you are used to find in a static language will appear: method not found, property not found,

incompatible types for method calls, number precision errors, &#8230;</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>In this section, we will describe the behavior of the type checker in various situations and explain the limits of using

<code>@TypeChecked</code> on your code.</p>

</div>

<div class="sect6">

<h7 id="_the_code_typechecked_code_annotation">The <code>@TypeChecked</code> annotation</h7>

<div class="sect7">

<h8 id="_activating_type_checking_at_compile_time">Activating type checking at compile time</h8>

<div class="paragraph">

<p>The <code>groovy.lang.TypeChecked</code> annotation enabled type checking. It can be placed on a class:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TypeChecked

class Calculator {

    int sum(int x, int y) { x+y }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>Or on a method:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Calculator {

    @groovy.transform.TypeChecked

    int sum(int x, int y) { x+y }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>In the first case, all methods, properties, fields, inner classes, &#8230; of the annotated class will be type checked, whereas

in the second case, only the method and potential closures or anonymous inner classes that it contains will be type checked.</p>

</div>

</div>

<div class="sect7">

<h8 id="_skipping_sections">Skipping sections</h8>

<div class="paragraph">

<p>The scope of type checking can be restricted. For example, if a class is type checked, you can instruct the type checker

to skip a method by annotating it with <code>@TypeChecked(TypeCheckingMode.SKIP)</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.TypeChecked

import groovy.transform.TypeCheckingMode


@TypeChecked                                        <i class="conum" data-value="1"></i><b>(1)</b>

class GreetingService {

    String greeting() {                             <i class="conum" data-value="2"></i><b>(2)</b>

        doGreet()

    }


    @TypeChecked(TypeCheckingMode.SKIP)             <i class="conum" data-value="3"></i><b>(3)</b>

    private String doGreet() {

        def b = new SentenceBuilder()

        b.Hello.my.name.is.John                     <i class="conum" data-value="4"></i><b>(4)</b>

        b

    }

}

def s = new GreetingService()

assert s.greeting() == 'Hello my name is John'</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>GreetingService</code> class is marked as type checked</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>so the <code>greeting</code> method is automatically type checked</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>but <code>doGreet</code> is marked with <code>SKIP</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>the type checker doesn&#8217;t complain about missing properties here</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>In the previous example, <code>SentenceBuilder</code> relies on dynamic code. There&#8217;s no real <code>Hello</code> method or property, so the

type checker would normally complain and compilation would fail. Since the method that uses the builder is marked with

<code>TypeCheckingMode.SKIP</code>, type checking is <em>skipped</em> for this method, so the code will compile, even if the rest of the

class is type checked.</p>

</div>

<div class="paragraph">

<p>The following sections describe the semantics of type checking in Groovy.</p>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_type_checking_assignments">Type checking assignments</h7>

<div class="paragraph">

<p>An object <code>o</code> of type <code>A</code> can be assigned to a variable of type <code>T</code> if and only if:</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>T</code> equals <code>A</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Date now = new Date()</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is one of <code>String</code>, <code>boolean</code>, <code>Boolean</code> or <code>Class</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String s = new Date() // implicit call to toString

Boolean boxed = 'some string'       // Groovy truth

boolean prim = 'some string'        // Groovy truth

Class clazz = 'java.lang.String'    // class coercion</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>o</code> is null and <code>T</code> is not a primitive type</p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String s = null         // passes

int i = null            // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is an array and <code>A</code> is an array and the component type of <code>A</code> is assignable to the component type of <code>B</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int[] i = new int[4]        // passes

int[] i = new String[4]     // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is an array and <code>A</code> is a list and the component type of <code>A</code> is assignable to the component type of <code>B</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int[] i = [1,2,3]               // passes

int[] i = [1,2, new Date()]     // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is a superclass of <code>A</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">AbstractList list = new ArrayList()     // passes

LinkedList list = new ArrayList()       // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is an interface implemented by <code>A</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">List list = new ArrayList()             // passes

RandomAccess list = new LinkedList()    // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> or <code>A</code> are a primitive type and their boxed types are assignable</p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int i = 0

Integer bi = 1

int x = new Integer(123)

double d = new Float(5f)</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> extends <code>groovy.lang.Closure</code> and <code>A</code> is a SAM-type (single abstract method type)</p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Runnable r = { println 'Hello' }

interface SAMType {

    int doSomething()

}

SAMType sam = { 123 }

assert sam.doSomething() == 123

abstract class AbstractSAM {

    int calc() { 2* value() }

    abstract int value()

}

AbstractSAM c = { 123 }

assert c.calc() == 246</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> and <code>A</code> derive from <code>java.lang.Number</code> and conform to the following table</p>

</li>

</ul>

</div>

<table id="number-assignment" class="tableblock frame-all grid-all" style="width: 100%;">

<caption class="title">Table 2. Number types (java.lang.XXX)</caption>

<colgroup>

<col style="width: 25%;">

<col style="width: 25%;">

<col style="width: 50%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">T</th>

<th class="tableblock halign-left valign-top">A</th>

<th class="tableblock halign-left valign-top">Examples</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Double</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Any but BigDecimal or BigInteger</p></td>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Double d1 = 4d

Double d2 = 4f

Double d3 = 4l

Double d4 = 4i

Double d5 = (short) 4

Double d6 = (byte) 4</code></pre>

</div>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Float</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger or Double</p></td>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Float f1 = 4f

Float f2 = 4l

Float f3 = 4i

Float f4 = (short) 4

Float f5 = (byte) 4</code></pre>

</div>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Long</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger, Double or Float</p></td>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Long l1 = 4l

Long l2 = 4i

Long l3 = (short) 4

Long l4 = (byte) 4</code></pre>

</div>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Integer</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger, Double, Float or Long</p></td>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Integer i1 = 4i

Integer i2 = (short) 4

Integer i3 = (byte) 4</code></pre>

</div>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Short</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Any type but BigDecimal, BigInteger, Double, Float, Long or Integer</p></td>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Short s1 = (short) 4

Short s2 = (byte) 4</code></pre>

</div>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><p class="tableblock">Byte</p></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Byte</p></td>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Byte b1 = (byte) 4</code></pre>

</div>

</div></div></td>

</tr>

</tbody>

</table>

</div>

<div class="sect6">

<h7 id="_list_and_map_constructors">List and map constructors</h7>

<div class="paragraph">

<p>In addition to the assignment rules above, if an assignment is deemed invalid, in type checked mode, a <em>list</em> literal or a <em>map</em> literal <code>A</code> can be assigned

to a variable of type <code>T</code> if:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>the assignment is a variable declaration and <code>A</code> is a list literal and <code>T</code> has a constructor whose parameters match the types of the elements in the list literal</p>

</li>

<li>

<p>the assignment is a variable declaration and <code>A</code> is a map literal and <code>T</code> has a no-arg constructor and a property for each of the map keys</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>For example, instead of writing:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TupleConstructor

class Person {

    String firstName

    String lastName

}

Person classic = new Person('Ada','Lovelace')</code></pre>

</div>

</div>

<div class="paragraph">

<p>You can use a "list constructor":</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Person list = ['Ada','Lovelace']</code></pre>

</div>

</div>

<div class="paragraph">

<p>or a "map constructor":</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Person map = [firstName:'Ada', lastName:'Lovelace']</code></pre>

</div>

</div>

<div class="paragraph">

<p>If you use a map constructor, additional checks are done on the keys of the map to check if a property of the same name

is defined. For example, the following will fail at compile time:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TupleConstructor

class Person {

    String firstName

    String lastName

}

Person map = [firstName:'Ada', lastName:'Lovelace', age: 24]     <i class="conum" data-value="1"></i><b>(1)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>The type checker will throw an error <code>No such property: age for class: Person</code> at compile time</td>

</tr>

</table>

</div>

</div>

<div class="sect6">

<h7 id="_method_resolution">Method resolution</h7>

<div class="paragraph">

<p>In type checked mode, methods are resolved at compile time. Resolution works by name and arguments. The return type is

irrelevant to method selection. Types of arguments are matched against the types of the parameters following those rules:</p>

</div>

<div class="paragraph">

<p>An argument <code>o</code> of type <code>A</code> can be used for a parameter of type <code>T</code> if and only if:</p>

</div>

<div class="ulist">

<ul>

<li>

<p><code>T</code> equals <code>A</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int sum(int x, int y) {

    x+y

}

assert sum(3,4) == 7</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is a <code>String</code> and <code>A</code> is a <code>GString</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String format(String str) {

    "Result: $str"

}

assert format("${3+4}") == "Result: 7"</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>o</code> is null and <code>T</code> is not a primitive type</p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String format(int value) {

    "Result: $value"

}

assert format(7) == "Result: 7"

format(null)           // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is an array and <code>A</code> is an array and the component type of <code>A</code> is assignable to the component type of <code>B</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String format(String[] values) {

    "Result: ${values.join(' ')}"

}

assert format(['a','b'] as String[]) == "Result: a b"

format([1,2] as int[])              // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is a superclass of <code>A</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String format(AbstractList list) {

    list.join(',')

}

format(new ArrayList())              // passes

String format(LinkedList list) {

    list.join(',')

}

format(new ArrayList())              // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> is an interface implemented by <code>A</code></p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String format(List list) {

    list.join(',')

}

format(new ArrayList())                  // passes

String format(RandomAccess list) {

    'foo'

}

format(new LinkedList())                 // fails</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> or <code>A</code> are a primitive type and their boxed types are assignable</p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int sum(int x, Integer y) {

    x+y

}

assert sum(3, new Integer(4)) == 7

assert sum(new Integer(3), 4) == 7

assert sum(new Integer(3), new Integer(4)) == 7

assert sum(new Integer(3), 4) == 7</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> extends <code>groovy.lang.Closure</code> and <code>A</code> is a SAM-type (single abstract method type)</p>

<div class="exampleblock result">

<div class="content">

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface SAMType {

    int doSomething()

}

int twice(SAMType sam) { 2*sam.doSomething() }

assert twice { 123 } == 246

abstract class AbstractSAM {

    int calc() { 2* value() }

    abstract int value()

}

int eightTimes(AbstractSAM sam) { 4*sam.calc() }

assert eightTimes { 123 } == 984</code></pre>

</div>

</div>

</div>

</div>

</li>

<li>

<p><em>or</em> <code>T</code> and <code>A</code> derive from <code>java.lang.Number</code> and conform to the same rules as <a href="groovy_language_specification.html#number-assignment">assignment of numbers</a></p>

</li>

</ul>

</div>

<div class="paragraph">

<p>If a method with the appropriate name and arguments is not found at compile time, an error is thrown. The difference with "normal" Groovy is

illustrated in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class MyService {

    void doSomething() {

        printLine 'Do something'            <i class="conum" data-value="1"></i><b>(1)</b>

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>printLine</code> is an error, but since we&#8217;re in a dynamic mode, the error is not caught at compile time</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The example above shows a class that Groovy will be able to compile. However, if you try to create an instance of <code>MyService</code> and call the

<code>doSomething</code> method, then it will fail <strong>at runtime</strong>, because <code>printLine</code> doesn&#8217;t exist. Of course, we already showed how Groovy could make

this a perfectly valid call, for example by catching <code>MethodMissingException</code> or implementing a custom meta-class, but if you know you&#8217;re

not in such a case, <code>@TypeChecked</code> comes handy:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class MyService {

    void doSomething() {

        printLine 'Do something'            <i class="conum" data-value="1"></i><b>(1)</b>

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>printLine</code> is this time a compile-time error</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Just adding <code>@TypeChecked</code> will trigger compile time method resolution. The type checker will try to find a method <code>printLine</code> accepting

a <code>String</code> on the <code>MyService</code> class, but cannot find one. It will fail compilation with the following message:</p>

</div>

<div class="paragraph">

<p><code>Cannot find matching method MyService#printLine(java.lang.String)</code></p>

</div>

<div class="exampleblock">

<div class="content">

<div class="admonitionblock important">

<table>

<tr>

<td class="icon">

<i class="icon-important" title="Important"></i>

</td>

<td class="content">

It is important to understand the logic behind the type checker: it is a compile-time check, so by definition, the type checker

is not aware of any kind of <strong>runtime</strong> metaprogramming that you do. This means that code which is perfectly valid without <code>@TypeChecked</code> will

<strong>not</strong> compile anymore if you activate type checking. This is in particular true if you think of duck typing:<br>

</td>

</tr>

</table>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Duck {

    void quack() {              <i class="conum" data-value="1"></i><b>(1)</b>

        println 'Quack!'

    }

}

class QuackingBird {

    void quack() {              <i class="conum" data-value="2"></i><b>(2)</b>

        println 'Quack!'

    }

}

@groovy.transform.TypeChecked

void accept(quacker) {

    quacker.quack()             <i class="conum" data-value="3"></i><b>(3)</b>

}

accept(new Duck())              <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>we define a <code>Duck</code> class which defines a <code>quack</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we define another <code>QuackingBird</code> class which also defines a <code>quack</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>quacker</code> is loosely typed, so since the method is <code>@TypeChecked</code>, we will obtain a compile-time error</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>even if in non type-checked Groovy, this would have passed</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>There are possible workarounds, like introducing an interface, but basically, by activating type checking, you gain type safety

but you loose some features of the language. Hopefully, Groovy introduces some features like flow typing to reduce the gap between

type-checked and non type-checked Groovy.</p>

</div>

</div>

</div>

</div>

<div class="sect6">

<h7 id="type-inference">Type inference</h7>

<div class="sect7">

<h8 id="_principles">Principles</h8>

<div class="paragraph">

<p>When code is annotated with <code>@TypeChecked</code>, the compiler performs type inference. It doesn&#8217;t simply rely on static types, but also uses various

techniques to infer the types of variables, return types, literals, &#8230; so that the code remains as clean as possible even if you activate the

type checker.</p>

</div>

<div class="paragraph">

<p>The simplest example is infering the type of a variable:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def message = 'Welcome to Groovy!'              <i class="conum" data-value="1"></i><b>(1)</b>

println message.toUpperCase()                   <i class="conum" data-value="2"></i><b>(2)</b>

println message.upper() // compile time error   <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>a variable is declared using the <code>def</code> keyword</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>calling <code>toUpperCase</code> is allowed by the type checker</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>calling <code>upper</code> will fail at compile time</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The reason the call to <code>toUpperCase</code> works is because the type of <code>message</code> was <em>inferred</em> as being a <code>String</code>.</p>

</div>

</div>

<div class="sect7">

<h8 id="_variables_vs_fields_in_type_inference">Variables vs fields in type inference</h8>

<div class="paragraph">

<p>It is worth noting that although the compiler performs type inference on local variables, it does <strong>not</strong> perform any kind

of type inference on fields, always falling back to the <strong>declared type</strong> of a field. To illustrate this, let&#8217;s take a

look at this example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class SomeClass {

    def someUntypedField                                                                <i class="conum" data-value="1"></i><b>(1)</b>

    String someTypedField                                                               <i class="conum" data-value="2"></i><b>(2)</b>


    void someMethod() {

        someUntypedField = '123'                                                        <i class="conum" data-value="3"></i><b>(3)</b>

        someUntypedField = someUntypedField.toUpperCase()  // compile-time error        <i class="conum" data-value="4"></i><b>(4)</b>

    }


    void someSafeMethod() {

        someTypedField = '123'                                                          <i class="conum" data-value="5"></i><b>(5)</b>

        someTypedField = someTypedField.toUpperCase()                                   <i class="conum" data-value="6"></i><b>(6)</b>

    }


    void someMethodUsingLocalVariable() {

        def localVariable = '123'                                                       <i class="conum" data-value="7"></i><b>(7)</b>

        someUntypedField = localVariable.toUpperCase()                                  <i class="conum" data-value="8"></i><b>(8)</b>

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>someUntypedField</code> uses <code>def</code> as a declaration type</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><code>someTypedField</code> uses <code>String</code> as a declaration type</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>we can assign <strong>anything</strong> to <code>someUntypedField</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>yet calling <code>toUpperCase</code> fails at compile time because the field is not typed properly</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>we can assign a <code>String</code> to a field of type <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>and this time <code>toUpperCase</code> is allowed</td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>if we assign a <code>String</code> to a local variable</td>

</tr>

<tr>

<td><i class="conum" data-value="8"></i><b>8</b></td>

<td>then calling <code>toUpperCase</code> is allowed on the local variable</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Why such a difference? The reason is <em>thread safety</em>. At compile time, we can&#8217;t make <strong>any</strong> guarantee about the type of

a field. Any thread can access any field at any time and between the moment a field is assigned a variable of some

type in a method and the time is is used the line after, another thread may have changed the contents of the field. This

is not the case for local variables: we know if they "escape" or not, so we can make sure that the type of a variable is

constant (or not) over time. Note that even if a field is final, the JVM makes no guarantee about it, so the type checker

doesn&#8217;t behave differently if a field is final or not.</p>

</div>

<div class="admonitionblock tip">

<table>

<tr>

<td class="icon">

<i class="icon-tip" title="Tip"></i>

</td>

<td class="content">

This is one of the reasons why we recommend to use <strong>typed</strong> fields. While using <code>def</code> for local variables is perfectly

fine thanks to type inference, this is not the case for fields, which also belong to the public API of a class, hence the

type is important.

</td>

</tr>

</table>

</div>

</div>

<div class="sect7">

<h8 id="_collection_literal_type_inference">Collection literal type inference</h8>

<div class="paragraph">

<p>Groovy provides a syntax for various type literals. There are three native collection literals in Groovy:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>lists, using the <code>[]</code> literal</p>

</li>

<li>

<p>maps, using the <code>[:]</code> literal</p>

</li>

<li>

<p>ranges, using the <code>(..,..)</code> literal</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>The inferred type of a literal depends on the elements of the literal, as illustrated in the following table:</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<colgroup>

<col style="width: 40%;">

<col style="width: 60%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">Literal</th>

<th class="tableblock halign-left valign-top">Inferred type</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def list = []</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>java.util.List</code></p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def list = ['foo','bar']</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>java.util.List&lt;String&gt;</code></p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def list = ["${foo}","${bar}"]</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>java.util.List&lt;GString&gt;</code> be careful, a <code>GString</code> is <strong>not</strong> a <code>String</code>!</p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def map = [:]</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>java.util.LinkedHashMap</code></p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def map1 = [someKey: 'someValue']

def map2 = ['someKey': 'someValue']</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>java.util.LinkedHashMap&lt;String,String&gt;</code></p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def map1 = [someKey: 'someValue']

def map2 = ['someKey': 'someValue']</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>java.util.LinkedHashMap&lt;GString,String&gt;</code> be careful, the key is a <code>GString</code>!</p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def intRange = (0..10)</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>groovy.lang.IntRange</code></p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def charRange = ('a'..'z')</code></pre>

</div>

</div></div></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>groovy.lang.Range&lt;String&gt;</code> : uses the type of the bounds to infer the component type of the range</p>

</div></div></td>

</tr>

</tbody>

</table>

<div class="paragraph">

<p>As you can see, with the noticeable exception of the <code>IntRange</code>, the inferred type makes use of generics types to describe

the contents of a collection. In case the collection contains elements of different types, the type checker still performs

type inference of the components, but uses the notion of <a href="groovy_language_specification.html#section-lub">least upper bound</a>.</p>

</div>

</div>

<div class="sect7">

<h8 id="section-lub">Least upper bound</h8>

<div class="paragraph">

<p>In Groovy, the <em>least upper bound</em> of two types <code>A</code> and <code>B</code> is defined as a type which:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>superclass corresponds to the common super class of <code>A</code> and <code>B</code></p>

</li>

<li>

<p>interfaces correspond to the interfaces implemented by both <code>A</code> and <code>B</code></p>

</li>

<li>

<p>if <code>A</code> or <code>B</code> is a primitive type and that <code>A</code> isn&#8217;t equal to <code>B</code>, the least upper bound of <code>A</code> and <code>B</code> is the least

upper bound of their wrapper types</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>If <code>A</code> and <code>B</code> only have one (1) interface in common and that their common superclass is <code>Object</code>, then the LUB of both

is the common interface.</p>

</div>

<div class="paragraph">

<p>The least upper bound represents the minimal type to which both <code>A</code> and <code>B</code> can be assigned. So for example, if <code>A</code> and <code>B</code>

are both <code>String</code>, then the LUB (least upper bound) of both is also <code>String</code>.</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Top {}

class Bottom1 extends Top {}

class Bottom2 extends Top {}


assert leastUpperBound(String, String) == String                    <i class="conum" data-value="1"></i><b>(1)</b>

assert leastUpperBound(ArrayList, LinkedList) == AbstractList       <i class="conum" data-value="2"></i><b>(2)</b>

assert leastUpperBound(ArrayList, List) == List                     <i class="conum" data-value="3"></i><b>(3)</b>

assert leastUpperBound(List, List) == List                          <i class="conum" data-value="4"></i><b>(4)</b>

assert leastUpperBound(Bottom1, Bottom2) == Top                     <i class="conum" data-value="5"></i><b>(5)</b>

assert leastUpperBound(List, Serializable) == Object                <i class="conum" data-value="6"></i><b>(6)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the LUB of <code>String</code> and <code>String</code> is <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the LUB of <code>ArrayList</code> and <code>LinkedList</code> is their common super type, <code>AbstractList</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the LUB of <code>ArrayList</code> and <code>List</code> is their only common interface, <code>List</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>the LUB of two identical interfaces is the interface itself</td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>the LUB of <code>Bottom1</code> and <code>Bottom2</code> is their superclass <code>Top</code></td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>the LUB of two types which have nothing in common is <code>Object</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>In those examples, the LUB is always representable as a normal, JVM supported, type. But Groovy internally represents the LUB

as a type which can be more complex, and that you wouldn&#8217;t be able to use to define a variable for example. To illustrate this,

let&#8217;s continue with this example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface Foo {}

class Top {}

class Bottom extends Top implements Serializable, Foo {}

class SerializableFooImpl implements Serializable, Foo {}</code></pre>

</div>

</div>

<div class="paragraph">

<p>What is the least upper bound of <code>Bottom</code> and <code>SerializableFooImpl</code>? They don&#8217;t have a common super class (apart from <code>Object</code>),

but they do share 2 interfaces (<code>Serializable</code> and <code>Foo</code>), so their least upper bound is a type which represents the union of

two interfaces (<code>Serializable</code> and <code>Foo</code>). This type cannot be defined in the source code, yet Groovy knows about it.</p>

</div>

<div class="paragraph">

<p>In the context of collection type inference (and generic type inference in general), this becomes handy, because the type of the

components is inferred as the least upper bound. We can illustrate why this is important in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface Greeter { void greet() }                  <i class="conum" data-value="1"></i><b>(1)</b>

interface Salute { void salute() }                  <i class="conum" data-value="2"></i><b>(2)</b>


class A implements Greeter, Salute {                <i class="conum" data-value="3"></i><b>(3)</b>

    void greet() { println "Hello, I'm A!" }

    void salute() { println "Bye from A!" }

}

class B implements Greeter, Salute {                <i class="conum" data-value="4"></i><b>(4)</b>

    void greet() { println "Hello, I'm B!" }

    void salute() { println "Bye from B!" }

    void exit() { println 'No way!' }               <i class="conum" data-value="5"></i><b>(5)</b>

}

def list = [new A(), new B()]                       <i class="conum" data-value="6"></i><b>(6)</b>

list.each {

    it.greet()                                      <i class="conum" data-value="7"></i><b>(7)</b>

    it.salute()                                     <i class="conum" data-value="8"></i><b>(8)</b>

    it.exit()                                       <i class="conum" data-value="9"></i><b>(9)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>Greeter</code> interface defines a single method, <code>greet</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the <code>Salute</code>  interface defines a single method, <code>salute</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>class <code>A</code> implements both <code>Greeter</code> and <code>Salute</code> but there&#8217;s no explicit interface extending both</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>same for <code>B</code></td>

</tr>

<tr>

<td><i class="conum" data-value="5"></i><b>5</b></td>

<td>but <code>B</code> defines an additional <code>exit</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="6"></i><b>6</b></td>

<td>the type of <code>list</code> is inferred as "list of the LUB of <code>A</code> and <code>B</code>"</td>

</tr>

<tr>

<td><i class="conum" data-value="7"></i><b>7</b></td>

<td>so it is possible to call <code>greet</code> which is defined on both <code>A</code> and <code>B</code> through the <code>Greeter</code> interface</td>

</tr>

<tr>

<td><i class="conum" data-value="8"></i><b>8</b></td>

<td>and it is possible to call <code>salut</code> which is defined on both <code>A</code> and <code>B</code> through the <code>Salut</code> interface</td>

</tr>

<tr>

<td><i class="conum" data-value="9"></i><b>9</b></td>

<td>yet calling <code>exit</code> is a compile time error because it doesn&#8217;t belong to the LUB of <code>A</code> and <code>B</code> (only defined in <code>B</code>)</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The error message will look like:</p>

</div>

<div class="listingblock">

<div class="content">

<pre>[Static type checking] - Cannot find matching method Greeter or Salute#exit()</pre>

</div>

</div>

<div class="paragraph">

<p>which indicates that the <code>exit</code> method is neither defines on <code>Greeter</code> nor <code>Salute</code>, which are the two interfaces defined

in the least upper bound of <code>A</code> and <code>B</code>.</p>

</div>

</div>

<div class="sect7">

<h8 id="_instanceof_inference">instanceof inference</h8>

<div class="paragraph">

<p>In normal, non type checked, Groovy, you can write things like:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Greeter {

    String greeting() { 'Hello' }

}


void doSomething(def o) {

    if (o instanceof Greeter) {     <i class="conum" data-value="1"></i><b>(1)</b>

        println o.greeting()        <i class="conum" data-value="2"></i><b>(2)</b>

    }

}


doSomething(new Greeter())</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>guard the method call with an <code>instanceof</code> check</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>make the call</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The method call works because of dynamic dispatch (the method is selected at runtime). The equivalent code in Java would

require to cast <code>o</code> to a <code>Greeter</code> before calling the <code>greeting</code> method, because methods are selected at compile time:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">if (o instanceof Greeter) {

    System.out.println(((Greeter)o).greeting());

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>However, in Groovy, even if you add <code>@TypeChecked</code> (and thus activate type checking) on the <code>doSomething</code> method, the

cast is <strong>not</strong> necessary. The compiler embeds <em>instanceof</em> inference that makes the cast optional.</p>

</div>

</div>

<div class="sect7">

<h8 id="section-flow-typing">Flow typing</h8>

<div class="paragraph">

<p>Flow typing is an important concept of Groovy in type checked mode and an extension of type inference. The idea is that

the compiler is capable of infering the type of variables in the flow of the code, not just at initialization:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TypeChecked

void flowTyping() {

    def o = 'foo'                       <i class="conum" data-value="1"></i><b>(1)</b>

    o = o.toUpperCase()                 <i class="conum" data-value="2"></i><b>(2)</b>

    o = 9d                              <i class="conum" data-value="3"></i><b>(3)</b>

    o = Math.sqrt(o)                    <i class="conum" data-value="4"></i><b>(4)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>first, <code>o</code> is declared using <code>def</code> and assigned a <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>the compiler inferred that <code>o</code> is a <code>String</code>, so calling <code>toUpperCase</code> is allowed</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>o</code> is reassigned with a <code>double</code></td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>calling <code>Math.sqrt</code> passes compilation because the compiler knows that at this point, <code>o</code> is a <code>double</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>So the type checker is <em>aware</em> of the fact that the concrete type of a variable is different over time. In particular,

if you replace the last assignment with:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">o = 9d

o = o.toUpperCase()</code></pre>

</div>

</div>

<div class="paragraph">

<p>The type checker will now fail at compile time, because it knows that <code>o</code> is a <code>double</code> when <code>toUpperCase</code> is called,

so it&#8217;s a type error.</p>

</div>

<div class="paragraph">

<p>It is important to understand that it is not the fact of declaring a variable with <code>def</code> that triggers type inference.

Flow typing works for <strong>any</strong> variable of any type. Declaring a variable with an explicit type only constraints what you

can assign to a variable:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TypeChecked

void flowTypingWithExplicitType() {

    List list = ['a','b','c']           <i class="conum" data-value="1"></i><b>(1)</b>

    list = list*.toUpperCase()          <i class="conum" data-value="2"></i><b>(2)</b>

    list = 'foo'                        <i class="conum" data-value="3"></i><b>(3)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>list</code> is declared as an unchecked <code>List</code> and assigned a list literal of `String`s</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>this line passes compilation because of flow typing: the type checker knows that <code>list</code> is at this point a <code>List&lt;String&gt;</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>but you can&#8217;t assign a <code>String</code> to a <code>List</code> so this is a type checking error</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>You can also note that even if the variable is declared <strong>without</strong> generics information, the type checker knows what is

the component type. Therefore, such code would fail compilation:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TypeChecked

void flowTypingWithExplicitType() {

    List list = ['a','b','c']           <i class="conum" data-value="1"></i><b>(1)</b>

    list.add(1)                         <i class="conum" data-value="2"></i><b>(2)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>list</code> is inferred as <code>List&lt;String&gt;</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>so adding an <code>int</code> to a <code>List&lt;String&gt;</code> is a compile-time error</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Fixing this requires adding an explicit generic type to the declaration:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TypeChecked

void flowTypingWithExplicitType() {

    List&lt;? extends Serializable&gt; list = []                      <i class="conum" data-value="1"></i><b>(1)</b>

    list.addAll(['a','b','c'])                                  <i class="conum" data-value="2"></i><b>(2)</b>

    list.add(1)                                                 <i class="conum" data-value="3"></i><b>(3)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>list</code> declared as <code>List&lt;? extends Serializable&gt;</code> and initialized with an empty list</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>elements added to the list conform to the declaration type of the list</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>so adding an <code>int</code> to a <code>List&lt;? extends Serializable&gt;</code> is allowed</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Flow typing has been introduced to reduce the difference in semantics between classic and static Groovy. In particular,

consider the behavior of this code in Java:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="java language-java">public Integer compute(String str) {

    return str.length();

}

public String compute(Object o) {

    return "Nope";

}

// ...

Object string = "Some string";          <i class="conum" data-value="1"></i><b>(1)</b>

Object result = compute(string);        <i class="conum" data-value="2"></i><b>(2)</b>

System.out.println(result);             <i class="conum" data-value="3"></i><b>(3)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td><code>o</code> is declared as an <code>Object</code> and assigned a <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we call the <code>compute</code> method with <code>o</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>and print the result</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>In Java, this code will output <code>0</code>, because method selection is done at compile time and based on the <strong>declared</strong> types.

So even if <code>o</code> is a <code>String</code> at runtime, it is still the <code>Object</code> version which is called, because <code>o</code> has been declared

as an <code>Object</code>. To be short, in Java, declared types are most important, be it variable types, parameter types or return

types.</p>

</div>

<div class="paragraph">

<p>In Groovy, we could write:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">int compute(String string) { string.length() }

String compute(Object o) { "Nope" }

Object o = 'string'

def result = compute(o)

println result</code></pre>

</div>

</div>

<div class="paragraph">

<p>But this time, it will return <code>6</code>, because the method which is chosen is chosen <strong>at runtime</strong>, based on the <em>actual</em>

argument types. So at runtime, <code>o</code> is a <code>String</code> so the <code>String</code> variant is used. Note that this behavior has nothing

to do with type checking, it&#8217;s the way Groovy works in general: dynamic dispatch.</p>

</div>

<div class="paragraph">

<p>In type checked Groovy, we want to make sure the type checker selects the same method <strong>at compile time</strong>, that the runtime

would choose. It is not possible in general, due to the semantics of the language, but we can make things better with flow

typing. With flow typing, <code>o</code> is <em>inferred</em> as a <code>String</code> when the <code>compute</code> method is called, so the version which takes

a <code>String</code> and returns an <code>int</code> is chosen. This means that we can infer the return type of the method to be an <code>int</code>, and

not a <code>String</code>. This is important for subsequent calls and type safety.</p>

</div>

<div class="paragraph">

<p>So in type checked Groovy, flow typing is a very important concept, which also implies that if <code>@TypeChecked</code> is applied,

methods are selected based on the <em>inferred types</em> of the arguments, not on the declared types. This doesn&#8217;t ensure 100%

type safety, because the type checker <em>may</em> select a wrong method, but it ensures the closest semantics to dynamic Groovy.</p>

</div>

</div>

<div class="sect7">

<h8 id="_advanced_type_inference">Advanced type inference</h8>

<div class="paragraph">

<p>A combination of <a href="groovy_language_specification.html#section-flow-typing">flow typing</a> and <a href="groovy_language_specification.html#section-lub">least upper bound inference</a> is used to perform

advanced type inference and ensure type safety in multiple situations. In particular, program control structures are

likely to alter the inferred type of a variable:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Top {

   void methodFromTop() {}

}

class Bottom extends Top {

   void methodFromBottom() {}

}

def o

if (someCondition) {

    o = new Top()                               <i class="conum" data-value="1"></i><b>(1)</b>

} else {

    o = new Bottom()                            <i class="conum" data-value="2"></i><b>(2)</b>

}

o.methodFromTop()                               <i class="conum" data-value="3"></i><b>(3)</b>

o.methodFromBottom()  // compilation error      <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>if <code>someCondition</code> is true, <code>o</code> is assigned a <code>Top</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>if <code>someCondition</code> is false, <code>o</code> is assigned a <code>Bottom</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>calling <code>methodFromTop</code> is safe</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td>but calling <code>methodFromBottom</code> is not, so it&#8217;s a compile time error</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>When the type checker visits an <code>if/else</code> control structure, it checks all variables which are assigned in <code>if/else</code> branches

and computes the <a href="groovy_language_specification.html#section-lub">least upper bound</a> of all assignments. This type is the type of the inferred variable

after the <code>if/else</code> block, so in this example, <code>o</code> is assigned a <code>Top</code> in the <code>if</code> branch and a <code>Bottom</code> in the <code>else</code>

branch. The <a href="groovy_language_specification.html#section-lub">LUB</a> of those is a <code>Top</code>, so after the conditional branches, the compiler infers <code>o</code> as being

a <code>Top</code>. Calling <code>methodFromTop</code> will therefore be allowed, but not <code>methodFromBottom</code>.</p>

</div>

<div class="paragraph">

<p>The same reasoning exists with closures and in particular closure shared variables. A closure shared variable is a variable

which is defined outside of a closure, but used inside a closure, as in this example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">def text = 'Hello, world!'                          <i class="conum" data-value="1"></i><b>(1)</b>

def closure = {

    println text                                    <i class="conum" data-value="2"></i><b>(2)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>a variable named <code>text</code> is declared</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><code>text</code> is used from inside a closure. It is a <em>closure shared variable</em>.</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Groovy allows developers to use those variables without requiring them to be final. This means that a closure shared

variable can be reassigned inside a closure:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">String result

doSomething { String it -&gt;

    result = "Result: $it"

}

result = result?.toUpperCase()</code></pre>

</div>

</div>

<div class="paragraph">

<p>The problem is that a closure is an independent block of code that can be executed (or not) at <strong>any</strong> time. In particular,

<code>doSomething</code> may be asynchronous, for example. This means that the body of a closure doesn&#8217;t belong to the main control

flow. For that reason, the type checker also computes, for each closure shared variable, the <a href="groovy_language_specification.html#section-lub">LUB</a> of all

assignments of the variable, and will use that <code>LUB</code> as the inferred type outside of the scope of the closure, like in

this example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Top {

   void methodFromTop() {}

}

class Bottom extends Top {

   void methodFromBottom() {}

}

def o = new Top()                               <i class="conum" data-value="1"></i><b>(1)</b>

Thread.start {

    o = new Bottom()                            <i class="conum" data-value="2"></i><b>(2)</b>

}

o.methodFromTop()                               <i class="conum" data-value="3"></i><b>(3)</b>

o.methodFromBottom()  // compilation error      <i class="conum" data-value="4"></i><b>(4)</b></code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>a closure-shared variable is first assigned a <code>Top</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>inside the closure, it is assigned a <code>Bottom</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td><code>methodFromTop</code> is allowed</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td><code>methodFromBottom</code> is a compilation error</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>Here, it is clear that when <code>methodFromBottom</code> is called, there&#8217;s no guarantee, at compile-time or runtime that the

type of <code>o</code> will <em>effectively</em> be a <code>Bottom</code>. There are chances that it will be, but we can&#8217;t make sure, because it&#8217;s

asynchronous. So the type checker will only allow calls on the <a href="groovy_language_specification.html#section-lub">least upper bound</a>, which is here a <code>Top</code>.</p>

</div>

</div>

</div>

<div class="sect6">

<h7 id="_closures_and_type_inference">Closures and type inference</h7>

<div class="paragraph">

<p>The type checker performs special inference on closures, resulting on additional checks on one side and improved fluency

on the other side.</p>

</div>

<div class="sect7">

<h8 id="_return_type_inference">Return type inference</h8>

<div class="paragraph">

<p>The first thing that the type checker is capable of doing is infering the <em>return type</em> of a closure. This is simply

 illustrated in the following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@groovy.transform.TypeChecked

int testClosureReturnTypeInference(String arg) {

    def cl = { "Arg: $arg" }                                <i class="conum" data-value="1"></i><b>(1)</b>

    def val = cl()                                          <i class="conum" data-value="2"></i><b>(2)</b>


    val.length()                                            <i class="conum" data-value="3"></i><b>(3)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>a closure is defined, and it returns a string (more precisely a <code>GString</code>)</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we call the closure and assign the result to a variable</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>the type checker inferred that the closure would return a string, so calling <code>length()</code> is allowed</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>As you can see, unlike a method which declares its return type explicitly, there&#8217;s no need to declare the return type

of a closure: its type is inferred from the body of the closure.</p>

</div>

<div class="sidebarblock">

<div class="content">

<div class="title">Closures vs methods</div>

<div class="paragraph">

<p>It&#8217;s worth noting that return type inference is only applicable to closures. While the type checker could do the

same on a method, it is in practice not desirable: <em>in general</em>, methods can be overriden and it is not statically

possible to make sure that the method which is called is not an overriden version. So flow typing would actually

think that a method returns something, while in reality, it could return something else, like illustrated in the

following example:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">@TypeChecked

class A {

    def compute() { 'some string' }             <i class="conum" data-value="1"></i><b>(1)</b>

    def computeFully() {

        compute().toUpperCase()                 <i class="conum" data-value="2"></i><b>(2)</b>

    }

}

@TypeChecked

class B extends A {

    def compute() { 123 }                       <i class="conum" data-value="3"></i><b>(3)</b>

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>class <code>A</code> defines a method <code>compute</code> which effectively returns a <code>String</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>this will fail compilation because the return type of <code>compute</code> is <code>def</code>(aka <code>Object</code>)</td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>class <code>B</code> extends <code>A</code> and redefines <code>compute</code>, this type returning an <code>int</code></td>

</tr>

</table>

</div>

<div class="paragraph">

<p>As you can see, if the type checker relied on the inferred return type of a method, with <a href="groovy_language_specification.html#section-flow-typing">flow typing</a>,

the type checker could determine that it is ok to call <code>toUpperCase</code>. It is in fact an <strong>error</strong>, because a subclass can

override <code>compute</code> and return a different object. Here, <code>B#compute</code> returns an <code>int</code>, so someone calling <code>computeFully</code>

on an instance of <code>B</code> would see a runtime error. The compiler prevents this from happening by using the declared return

type of methods instead of the inferred return type.</p>

</div>

<div class="paragraph">

<p>For consistency, this behavior is the same for <strong>every</strong> method, even if they are static or final.</p>

</div>

</div>

</div>

</div>

<div class="sect7">

<h8 id="_parameter_type_inference">Parameter type inference</h8>

<div class="paragraph">

<p>In addition to the return type, it is possible for a closure to infer its parameter types from the context. There are

two ways for the compiler to infer the parameter types:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>through <em>implicit SAM type coercion</em></p>

</li>

<li>

<p>through API metadata</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>To illustrate this, lets start with an example that will fail compilation due to the inability for the type checker

to infer the parameter types:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Person {

    String name

    int age

}


void inviteIf(Person p, Closure&lt;Boolean&gt; predicate) {           <i class="conum" data-value="1"></i><b>(1)</b>

    if (predicate.call(p)) {

        // send invite

        // ...

    }

}


@groovy.transform.TypeChecked

void failCompilation() {

    Person p = new Person(name: 'Gerard', age: 55)

    inviteIf(p) {                                               <i class="conum" data-value="2"></i><b>(2)</b>

        it.age &gt;= 18 // No such property: age                   <i class="conum" data-value="3"></i><b>(3)</b>

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the <code>inviteIf</code> method accepts a <code>Person</code> and a <code>Closure</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>we call it with a <code>Person</code> and a <code>Closure</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>yet <code>it</code> is not statically known as being a <code>Person</code> and compilation fails</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>In this example, the closure body contains <code>it.age</code>. With dynamic, not type checked code, this would work, because the

type of <code>it</code> would be a <code>Person</code> at runtime. Unfortunately, at compile-time, there&#8217;s no way to know what is the type

of <code>it</code>, just by reading the signature of <code>inviteIf</code>.</p>

</div>

<div class="sect8">

<h9 id="_explicit_closure_parameters">Explicit closure parameters</h9>

<div class="paragraph">

<p>To be short, the type checker doesn&#8217;t have enough contextual information on the <code>inviteIf</code> method to determine statically

the type of <code>it</code>. This means that the method call needs to be rewritten like this:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">inviteIf(p) { Person it -&gt;                                  <i class="conum" data-value="1"></i><b>(1)</b>

    it.age &gt;= 18

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the type of <code>it</code> needs to be declared explicitly</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>By explicitly declaring the type of the <code>it</code> variable, you can workaround the problem and make this code statically

checked.</p>

</div>

</div>

<div class="sect8">

<h9 id="_parameters_inferred_from_single_abstract_method_types">Parameters inferred from single-abstract method types</h9>

<div class="paragraph">

<p>For an API or framework designer, there are two ways to make this more elegant for users, so that they don&#8217;t have to

declare an explicit type for the closure parameters. The first one, and easiest, is to replace the closure with a

SAM type:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">interface Predicate&lt;On&gt; { boolean apply(On e) }                 <i class="conum" data-value="1"></i><b>(1)</b>


void inviteIf(Person p, Predicate&lt;Person&gt; predicate) {          <i class="conum" data-value="2"></i><b>(2)</b>

    if (predicate.apply(p)) {

        // send invite

        // ...

    }

}


@groovy.transform.TypeChecked

void passesCompilation() {

    Person p = new Person(name: 'Gerard', age: 55)


    inviteIf(p) {                                               <i class="conum" data-value="3"></i><b>(3)</b>

        it.age &gt;= 18                                            <i class="conum" data-value="4"></i><b>(4)</b>

    }

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>declare a <code>SAM</code> interface with an <code>apply</code> method</td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td><code>inviteIf</code> now uses a <code>Predicate&lt;Person&gt;</code> instead of a <code>Closure&lt;Boolean&gt;</code></td>

</tr>

<tr>

<td><i class="conum" data-value="3"></i><b>3</b></td>

<td>there&#8217;s no need to declare the type of the <code>it</code> variable anymore</td>

</tr>

<tr>

<td><i class="conum" data-value="4"></i><b>4</b></td>

<td><code>it.age</code> compiles properly, the type of <code>it</code> is inferred from the <code>Predicate#apply</code> method signature</td>

</tr>

</table>

</div>

<div class="admonitionblock tip">

<table>

<tr>

<td class="icon">

<i class="icon-tip" title="Tip"></i>

</td>

<td class="content">

By using this technique, we leverage the <em>automatic coercion of closures to SAM types</em> feature of Groovy. The

question whether you should use a <em>SAM type</em> or a <em>Closure</em> really depends on what you need to do. In a lot of cases,

using a SAM interface is enough, especially if you consider functional interfaces as they are found in Java 8. However,

closures provide features that are not accessible to functional interfaces. In particular, closures can have a delegate,

and owner and can be manipulated as objects (for example, cloned, serialized, curried, &#8230;) before being called. They can

also support multiple signatures (polymorphism). So if you need that kind of manipulation, it is preferable to switch to

the most advanced type inference annotations which are described below.

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The original issue that needs to be solved when it comes to closure parameter type inference, that is to say, statically

determining the types of the arguments of a closure <em>without</em> having to have them explicitly declared, is that the Groovy

type system inherits the Java type system, which is insufficient to describe the types of the arguments.</p>

</div>

</div>

<div class="sect8">

<h9 id="_the_code_closureparams_code_annotation">The <code>@ClosureParams</code> annotation</h9>

<div class="paragraph">

<p>Groovy provides an annotation, <code>@ClosureParams</code> which is aimed at completing type information. This annotation is primarily

aimed at framework and API developers who want to extend the capabilities of the type checker by providing type inference

metadata. This is important if your library makes use of closures and that you want the maximum level of tooling support

too.</p>

</div>

<div class="paragraph">

<p>Let&#8217;s illustrate this by fixing the original example, introducing the <code>@ClosureParams</code> annotation:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.ClosureParams

import groovy.transform.stc.FirstParam

void inviteIf(Person p, @ClosureParams(FirstParam) Closure&lt;Boolean&gt; predicate) {        <i class="conum" data-value="1"></i><b>(1)</b>

    if (predicate.call(p)) {

        // send invite

        // ...

    }

}

inviteIf(p) {                                                                       <i class="conum" data-value="2"></i><b>(2)</b>

    it.age &gt;= 18

}</code></pre>

</div>

</div>

<div class="colist arabic">

<table>

<tr>

<td><i class="conum" data-value="1"></i><b>1</b></td>

<td>the closure parameter is annotated with <code>@ClosureParams</code></td>

</tr>

<tr>

<td><i class="conum" data-value="2"></i><b>2</b></td>

<td>it&#8217;s not necessary to use an explicit type for <code>it</code>, which is inferred</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>The <code>@ClosureParams</code> annotation minimally accepts one argument, which is named a <em>type hint</em>. A type hint is a class which

is reponsible for completing type information at compile time for the closure. In this example, the type hint being used

is <code>groovy.transform.stc.FirstParam</code> which indicated to the type checker that the closure will accept one parameter

whose type is the type of the first parameter of the method. In this case, the first parameter of the method is <code>Person</code>,

so it indicates to the type checker that the first parameter of the closure is in fact a <code>Person</code>.</p>

</div>

<div class="paragraph">

<p>The second argument is optional and named <em>options</em>. It&#8217;s semantics depends on the <em>type hint</em> class. Groovy comes with

various bundled type hints, illustrated in the table below:</p>

</div>

<table class="tableblock frame-all grid-all" style="width: 100%;">

<caption class="title">Table 3. Predefined type hints</caption>

<colgroup>

<col style="width: 16%;">

<col style="width: 16%;">

<col style="width: 66%;">

</colgroup>

<thead>

<tr>

<th class="tableblock halign-left valign-top">Type hint</th>

<th class="tableblock halign-left valign-top">Polymorphic?</th>

<th class="tableblock halign-left valign-top">Description and examples</th>

</tr>

</thead>

<tbody>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>FirstParam</code><br>

<code>SecondParam</code><br>

<code>ThirdParam</code></p>

</div></div></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p>The first (resp. second, third) parameter type of the method<br></p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.FirstParam

void doSomething(String str, @ClosureParams(FirstParam) Closure c) {

    c(str)

}

doSomething('foo') { println it.toUpperCase() }</code></pre>

</div>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.SecondParam

void withHash(String str, int seed, @ClosureParams(SecondParam) Closure c) {

    c(31*str.hashCode()+seed)

}

withHash('foo', (int)System.currentTimeMillis()) {

    int mod = it%2

}</code></pre>

</div>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.ThirdParam

String format(String prefix, String postfix, String o, @ClosureParams(ThirdParam) Closure c) {

    "$prefix${c(o)}$postfix"

}

assert format('foo', 'bar', 'baz') {

    it.toUpperCase()

} == 'fooBAZbar'</code></pre>

</div>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>FirstParam.FirstGenericType</code><br>

<code>SecondParam.FirstGenericType</code><br>

<code>ThirdParam.FirstGenericType</code></p>

</div></div></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p>The first generic type of the first (resp. second, third) parameter of the method<br></p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.FirstParam

public &lt;T&gt; void doSomething(List&lt;T&gt; strings, @ClosureParams(FirstParam.FirstGenericType) Closure c) {

    strings.each {

        c(it)

    }

}

doSomething(['foo','bar']) { println it.toUpperCase() }

doSomething([1,2,3]) { println(2*it) }</code></pre>

</div>

</div>

<div class="paragraph">

<p>Variants for <code>SecondGenericType</code> and <code>ThirdGenericType</code> exist for all <code>FirstParam</code>, <code>SecondParam</code> and <code>ThirdParam</code>

type hints.</p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>SimpleType</code></p>

</div></div></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">No</p></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p>A type hint for which the type of closure parameters comes from the options string.<br></p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.SimpleType

public void doSomething(@ClosureParams(value=SimpleType,options=['java.lang.String','int']) Closure c) {

    c('foo',3)

}

doSomething { str, len -&gt;

    assert str.length() == len

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>This type hint supports a <strong>single</strong> signature and each of the parameter is specified as a value of the <em>options</em> array

using a fully-qualified type name or a primitive type.</p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>MapEntryOrKeyValue</code></p>

</div></div></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p>A dedicated type hint for closures that either work on a <code>Map.Entry</code> single parameter, or two parameters corresponding

to the key and the value.<br></p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.MapEntryOrKeyValue

public &lt;K,V&gt; void doSomething(Map&lt;K,V&gt; map, @ClosureParams(MapEntryOrKeyValue) Closure c) {

    // ...

}

doSomething([a: 'A']) { k,v -&gt;

    assert k.toUpperCase() == v.toUpperCase()

}

doSomething([abc: 3]) { e -&gt;

    assert e.key.length() == e.value

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>This type hint <strong>requires</strong> that the first argument is a <code>Map</code> type, and infers the closure parameter types from the map

actual key/value types.</p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>FromAbstractTypeMethods</code></p>

</div></div></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p>Infers closure parameter types from the abstract method of some type. A signature is inferred for <strong>each</strong> abstract method.<br></p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.FromAbstractTypeMethods

abstract class Foo {

    abstract void firstSignature(int x, int y)

    abstract void secondSignature(String str)

}

void doSomething(@ClosureParams(value=FromAbstractTypeMethods, options=["Foo"]) Closure cl) {

    // ...

}

doSomething { a, b -&gt; a+b }

doSomething { s -&gt; s.toUpperCase() }</code></pre>

</div>

</div>

<div class="paragraph">

<p>If there are multiple signatures like in the example above, the type checker will <strong>only</strong> be able to infer the types of

the arguments if the arity of each method is different. In the example above, <code>firstSignature</code> takes 2 arguments and

<code>secondSignature</code> takes 1 argument, so the type checker can infer the argument types based on the number of arguments.</p>

</div></div></td>

</tr>

<tr>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p><code>FromString</code></p>

</div></div></td>

<td class="tableblock halign-left valign-top"><p class="tableblock">Yes</p></td>

<td class="tableblock halign-left valign-top"><div><div class="paragraph">

<p>Infers the closure parameter typs from the <code>options</code> argument. The <code>options</code> argument consists of an array of comma-separated

non-primitive types. Each element of the array corresponds to a single signature, and each comma in an element separate

parameters of the signature. In short, this is the most generic type hint, and each string of the <code>options</code> map is <strong>parsed</strong>

as if it was a signature literal. While being very powerful, this type hint must be avoided if you can because it increases

the compilation times due to the necessity of parsing the type signatures.</p>

</div>

<div class="paragraph">

<p>A single signature for a closure accepting a <code>String</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.FromString

void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {

    // ...

}

doSomething { s -&gt; s.toUpperCase() }

doSomething { s,i -&gt; s.toUpperCase()*i }</code></pre>

</div>

</div>

<div class="paragraph">

<p>A polymorphic closure, accepting either a <code>String</code> or a <code>String, Integer</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.FromString

void doSomething(@ClosureParams(value=FromString, options=["String","String,Integer"]) Closure cl) {

    // ...

}

doSomething { s -&gt; s.toUpperCase() }

doSomething { s,i -&gt; s.toUpperCase()*i }</code></pre>

</div>

</div>

<div class="paragraph">

<p>A polymorphic closure, accepting either a <code>T</code> or a pair <code>T,T</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">import groovy.transform.stc.FromString

public &lt;T&gt; void doSomething(T e, @ClosureParams(value=FromString, options=["T","T,T"]) Closure cl) {

    // ...

}

doSomething('foo') { s -&gt; s.toUpperCase() }

doSomething('foo') { s1,s2 -&gt; assert s1.toUpperCase() == s2.toUpperCase() }</code></pre>

</div>

</div></div></td>

</tr>

</tbody>

</table>

<div class="admonitionblock tip">

<table>

<tr>

<td class="icon">

<i class="icon-tip" title="Tip"></i>

</td>

<td class="content">

Even though you use <code>FirstParam</code>, <code>SecondParam</code> or <code>ThirdParam</code> as a type hint, it doesn&#8217;t stricly mean that the

argument which will be passed to the closure <strong>will</strong> be the first (resp. second, third) argument of the method call. It

only means that the <strong>type</strong> of the parameter of the closure will be the <strong>same</strong> as the type of the first (resp.  second,

 third) argument of the method call.

</td>

</tr>

</table>

</div>

<div class="paragraph">

<p>In short, the lack of the <code>@ClosureParams</code> annotation on a method accepting a <code>Closure</code> will <strong>not</strong> fail compilation. If

 present (and it can be present in Java sources as well as Groovy sources), then the type checker has <strong>more</strong> information

 and can perform additional type inference. This makes this feature particularily interesting for framework developers.</p>

</div>

</div>

</div>

<div class="sect7">

<h8 id="__code_delegatesto_code"><code>@DelegatesTo</code></h8>

<div class="paragraph">

<p>The <code>@DelegatesTo</code> annotation is used by the type checker to infer the type of the delegate. It allows the API designer

to instruct the compiler what is the type of the delegate and the delegation strategy. The <code>@DelegatesTo</code> annotation is

discussed in a <a href="core-domain-specific-languages.html#section-delegatesto">specific section</a>.</p>

</div>

</div>

</div>

</div>

<div class="sect5">

<h6 id="_static_compilation_wip">Static compilation (WIP)</h6>

<div class="sect6">

<h7 id="_dynamic_vs_static">Dynamic vs static</h7>

<div class="paragraph">

<p>In the <a href="groovy_language_specification.html#typechecking">type checking section</a>, we have seen that Groovy provides optional type checking thanks to the

<code>@TypeChecked</code> annotation. The type checker runs at compile time and performs a static analysis of dynamic code. The

program will behave exactly the same whether type checking has been enabled or not. This means that the <code>@TypeChecked</code>

annotation is neutral with regards to the semantics of a program. Even though it may be necessary to add type information

in the sources so that the program is considered type safe, in the end, the semantics of the program are the same.</p>

</div>

<div class="paragraph">

<p>While this may sound fine, there is actually one issue with this: type checking of dynamic code, done at compile time, is

by definition only correct if no runtime specific behavior occurs. For example, the following program passes type checking:</p>

</div>

<div id="typechecked-defeated" class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Computer {

    int compute(String str) {

        str.length()

    }

    String compute(int x) {

        String.valueOf(x)

    }

}


@groovy.transform.TypeChecked

void test() {

    def computer = new Computer()

    computer.with {

        assert compute(compute('foobar')) =='6'

    }

}</code></pre>

</div>

</div>

<div class="paragraph">

<p>There are two <code>compute</code> methods. One accepts a <code>String</code> and returns an <code>int</code>, the other accepts an <code>int</code> and returns

a <code>String</code>. If you compile this, it is considered type safe: the inner <code>compute('foobar')</code> call will return an <code>int</code>,

and calling <code>compute</code> on this <code>int</code> will in turn return a <code>String</code>.</p>

</div>

<div class="paragraph">

<p>Now, before calling <code>test()</code>, consider adding the following line:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">Computer.metaClass.compute = { String str -&gt; new Date() }</code></pre>

</div>

</div>

<div class="paragraph">

<p>Using runtime metaprogramming, we&#8217;re actually modifying the behavior of the <code>compute(String)</code> method, so that instead of

returning the length of the provided argument, it will return a <code>Date</code>. If you execute the program, it will fail at

runtime. Since this line can be added from anywhere, in any thread, there&#8217;s absolutely no way for the type checker to

statically make sure that no such thing happens. In short, the type checker is vulnerable to monkey patching. This is

just one example, but this illustrates the concept that doing static analysis of a dynamic program is inherently wrong.</p>

</div>

<div class="paragraph">

<p>The Groovy language provides an alternative annotation to <code>@TypeChecked</code> which will actually make sure that the methods

which are inferred as being called <strong>will</strong> effectively be called at runtime. This annotation turns the Groovy compiler

into a <strong>static compiler</strong>, where all method calls are resolved at compile time <strong>and</strong> the generated bytecode makes sure

that this happens: the annotation is <code>@groovy.transform.CompileStatic</code>.</p>

</div>

</div>

<div class="sect6">

<h7 id="compilestatic-annotation">The <code>@CompileStatic</code> annotation</h7>

<div class="paragraph">

<p>The <code>@CompileStatic</code> annotation can be added anywhere the <code>@TypeChecked</code> annotation can be used, that is to say on

a class or a method. It is not necessary to add both <code>@TypeChecked</code> and <code>@CompileStatic</code>, as <code>@CompileStatic</code> performs

everything <code>@TypeChecked</code> does, but in addition triggers static compilation.</p>

</div>

<div class="paragraph">

<p>Let&#8217;s take the <a href="groovy_language_specification.html#typechecked-defeated">example which failed</a>, but this time let&#8217;s replace the <code>@TypeChecked</code> annotation

with <code>@CompileStatic</code>:</p>

</div>

<div class="listingblock">

<div class="content">

<pre class="prettyprint"><code class="groovy language-groovy">class Computer {

    int compute(String str) {

        str.length()

    }

    String compute(int x) {

        String.valueOf(x)

    }

}


@groovy.transform.CompileStatic

void test() {

    def computer = new Computer()

    computer.with {

        assert compute(compute('foobar')) =='6'

    }

}

Computer.metaClass.compute = { String str -&gt; new Date() }

run()</code></pre>

</div>

</div>

<div class="paragraph">

<p>This is the <strong>only</strong> difference. If we execute this program, this time, there is no runtime error. The <code>test</code> method

became immune to monkey patching, because the <code>compute</code> methods which are called in its body are linked at compile

time, so even if the metaclass of <code>Computer</code> changes, the program still behaves <strong>as expected by the type checker</strong>.</p>

</div>

</div>

<div class="sect6">

<h7 id="_key_benefits">Key benefits</h7>

<div class="paragraph">

<p>There are several benefits of using <code>@CompileStatic</code> on your code:</p>

</div>

<div class="ulist">

<ul>

<li>

<p>type safety</p>

</li>

<li>

<p>immunity to <a href="groovy_language_specification.html#compilestatic-annotation">monkey patching</a></p>

</li>

<li>

<p>performance improvements</p>

</li>

</ul>

</div>

<div class="paragraph">

<p>The performance improvements depend on the kind of program you are executing. It it is I/O bound, the difference between

statically compiled code and dynamic code is barely noticeable. On highly CPU intensive code, since the bytecode which

is generated is very close, if not equal, to the one that Java would produce for an equivalent program, the performance

is greatly improved.</p>

</div>

<div class="admonitionblock tip">

<table>

<tr>

<td class="icon">

<i class="icon-tip" title="Tip"></i>

</td>

<td class="content">

Using the <em>invokedynamic</em> version of Groovy, which is accessible to people using JDK 7 and above, the performance

of the dynamic code should be very close to the performance of statically compiled code. Sometimes, it can even be faster!

There is only one way to determine which version you should choose: measuring. The reason is that depending on your program

<strong>and</strong> the JVM that you use, the performance can be significantly different. In particular, the <em>invokedynamic</em> version of

Groovy is very sensitive to the JVM version in use.

</td>

</tr>

</table>

</div>

</div>

</div>

</div>

</div>

</div>

</div>

</div>



</div>

<div id="footer">

<div id="footer-text">

Version 2.3.6<br>

Last updated 2014-07-28 15:13:29 CEST

</div>

</div>

</body>

</html>
